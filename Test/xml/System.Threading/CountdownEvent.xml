<Type Name="CountdownEvent" FullName="System.Threading.CountdownEvent">
  <TypeSignature Language="C#" Value="public class CountdownEvent : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CountdownEvent extends System.Object implements class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Initial Count={InitialCount}, Current Count={CurrentCount}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a synchronization primitive that is signaled when its count reaches zero.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CountdownEvent (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">The number of signals initially required to set the &lt;see cref="T:System.Threading.CountdownEvent"&gt;.</param>
        <summary>Initializes a new instance of &lt;see cref="T:System.Threading.CountdownEvent"&gt; class with the specified count.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 iI  is 0, the event is created in a signaled state.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCount">
      <MemberSignature Language="C#" Value="public void AddCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCount() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Increments the &lt;see cref="T:System.Threading.CountdownEvent"&gt;'s current count by one.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCount">
      <MemberSignature Language="C#" Value="public void AddCount (int signalCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCount(int32 signalCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signalCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="signalCount">The value by which to increase &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt;.</param>
        <summary>Increments the &lt;see cref="T:System.Threading.CountdownEvent"&gt;'s current count by a specified value.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of remaining signals required to set the event.</summary>
        <value>The number of remaining signals required to set the event.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the &lt;see cref="T:System.Threading.CountdownEvent"&gt; class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Call `Dispose` when you are finished using the <xref:System.Threading.CountdownEvent>. The `Dispose` method leaves the <xref:System.Threading.CountdownEvent> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Threading.CountdownEvent> so the garbage collector can reclaim the memory that the <xref:System.Threading.CountdownEvent> was occupying.  
  
 For more information, see [Cleaning Up Unmanaged Resources](../Topic/Cleaning%20Up%20Unmanaged%20Resources.md) and [Implementing a Dispose Method](../Topic/Implementing%20a%20Dispose%20Method.md).  
  
> [!NOTE]
>  Always call `Dispose` before you release your last reference to the <xref:System.Threading.CountdownEvent>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Threading.CountdownEvent> object's `Finalize` method.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the &lt;see cref="T:System.Threading.CountdownEvent"&gt;, and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unlike most of the members of <xref:System.Threading.CountdownEvent>, <xref:System.Threading.CountdownEvent.Dispose%2A> is not thread-safe and may not be used concurrently with other members of this instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitialCount">
      <MemberSignature Language="C#" Value="public int InitialCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InitialCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the numbers of signals initially required to set the event.</summary>
        <value>The number of signals initially required to set the event.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSet">
      <MemberSignature Language="C#" Value="public bool IsSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether the &lt;see cref="T:System.Threading.CountdownEvent"&gt; object's current count has reached zero..</summary>
        <value>`true` if the current count is zero; otherwise, `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Threading.CountdownEvent> does not raise an event when the countdown has reached zero. Instead, the <xref:System.Threading.CountdownEvent.CurrentCount%2A> property equals zero, and the IsSet property equals `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt; to the value of &lt;xref:System.Threading.CountdownEvent.InitialCount%2A&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unlike most of the members of <xref:System.Threading.CountdownEvent>, Reset is not thread-safe and may not be used concurrently with other members of this instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset(int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of signals required to set the &lt;see cref="T:System.Threading.CountdownEvent"&gt;.</param>
        <summary>Resets the &lt;xref:System.Threading.CountdownEvent.InitialCount%2A&gt; property to a specified value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method resets <xref:System.Threading.CountdownEvent.InitialCount%2A> for all subsequent accesses of the property on the current instance. Unlike most of the members of <xref:System.Threading.CountdownEvent>, Reset is not thread-safe and may not be used concurrently with other members of this instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Signal">
      <MemberSignature Language="C#" Value="public bool Signal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Signal() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Registers a signal with the &lt;see cref="T:System.Threading.CountdownEvent"&gt;, decrementing the value of &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt;.</summary>
        <returns>true if the signal caused the count to reach zero and the event was set; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Signal">
      <MemberSignature Language="C#" Value="public bool Signal (int signalCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Signal(int32 signalCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signalCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="signalCount">The number of signals to register.</param>
        <summary>Registers multiple signals with the &lt;see cref="T:System.Threading.CountdownEvent"&gt;, decrementing the value of &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt; by the specified amount.</summary>
        <returns>true if the signals caused the count to reach zero and the event was set; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAddCount">
      <MemberSignature Language="C#" Value="public bool TryAddCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAddCount() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to increment &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt; by one.</summary>
        <returns>true if the increment succeeded; otherwise, false. If &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt; is already at zero, this method will return false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAddCount">
      <MemberSignature Language="C#" Value="public bool TryAddCount (int signalCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAddCount(int32 signalCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signalCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="signalCount">The value by which to increase &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt;.</param>
        <summary>Attempts to increment &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt; by a specified value.</summary>
        <returns>true if the increment succeeded; otherwise, false. If &lt;xref:System.Threading.CountdownEvent.CurrentCount%2A&gt; is already at zero this will return false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocks the current thread until the &lt;see cref="T:System.Threading.CountdownEvent"&gt; is set.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The caller of this method blocks indefinitely until the current instance is set. The caller will return immediately if the event is currently in a set state.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or &lt;see cref="F:System.Threading.Timeout.Infinite"&gt;(-1) to wait indefinitely.</param>
        <summary>Blocks the current thread until the &lt;see cref="T:System.Threading.CountdownEvent"&gt; is set, using a 32-bit signed integer to measure the timeout.</summary>
        <returns>true if the &lt;see cref="T:System.Threading.CountdownEvent"&gt; was set; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">The &lt;see cref="T:System.Threading.CancellationToken"&gt; to observe.</param>
        <summary>Blocks the current thread until the &lt;see cref="T:System.Threading.CountdownEvent"&gt; is set, while observing a &lt;xref:System.Threading.CancellationToken&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The caller of this method blocks indefinitely until the current instance is set. The caller will return immediately if the event is currently in a set state. If the <xref:System.Threading.CancellationToken> being observed is canceled during the wait operation, an <xref:System.OperationCanceledException> will be thrown.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A &lt;see cref="T:System.TimeSpan"&gt; that represents the number of milliseconds to wait, or a &lt;see cref="T:System.TimeSpan"&gt; that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Blocks the current thread until the &lt;see cref="T:System.Threading.CountdownEvent"&gt; is set, using a &lt;xref:System.TimeSpan&gt; to measure the timeout.</summary>
        <returns>true if the &lt;see cref="T:System.Threading.CountdownEvent"&gt; was set; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or &lt;see cref="F:System.Threading.Timeout.Infinite"&gt;(-1) to wait indefinitely.</param>
        <param name="cancellationToken">The &lt;see cref="T:System.Threading.CancellationToken"&gt; to observe.</param>
        <summary>Blocks the current thread until the &lt;see cref="T:System.Threading.CountdownEvent"&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;xref:System.Threading.CancellationToken&gt;.</summary>
        <returns>true if the &lt;see cref="T:System.Threading.CountdownEvent"&gt; was set; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">A &lt;see cref="T:System.TimeSpan"&gt; that represents the number of milliseconds to wait, or a &lt;see cref="T:System.TimeSpan"&gt; that represents -1 milliseconds to wait indefinitely.</param>
        <param name="cancellationToken">The &lt;see cref="T:System.Threading.CancellationToken"&gt; to observe.</param>
        <summary>Blocks the current thread until the &lt;see cref="T:System.Threading.CountdownEvent"&gt; is set, using a &lt;xref:System.TimeSpan&gt; to measure the timeout, while observing a &lt;xref:System.Threading.CancellationToken&gt;.</summary>
        <returns>true if the &lt;see cref="T:System.Threading.CountdownEvent"&gt; was set; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle WaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle WaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a &lt;see cref="T:System.Threading.WaitHandle"&gt; that is used to wait for the event to be set.</summary>
        <value>A &lt;see cref="T:System.Threading.WaitHandle"&gt; that is used to wait for the event to be set.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 WaitHandle should only be used if it's needed for integration with code bases that rely on having a WaitHandle. If all that's needed is to wait for the <xref:System.Threading.CountdownEvent> to be set, the <xref:System.Threading.CountdownEvent.Wait%2A> method should be preferred.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>