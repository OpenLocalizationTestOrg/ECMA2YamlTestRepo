<Type Name="Math" FullName="System.Math">
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.  
  
 To browse the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/math.cs#a4407e67b9a5afad).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/math.cs#a4407e67b9a5afad). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
   
  
## Examples  
 The following example uses several mathematical and trigonometric functions from the Math class to calculate the inner angles of a trapezoid.  
  
 [!CODE [MathSample#1](../CodeSnippet/VS_Snippets_CLR/MathSample#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than or equal to &lt;xref:System.Decimal?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.Decimal?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of a &lt;see cref="T:System.Decimal"&gt; number.</summary>
        <returns>A decimal number, x, such that 0 ≤ x ≤&lt;xref:System.Decimal?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a <xref:System.Decimal> is its numeric value without its sign. For example, the absolute value of both 1.2 and -1.2 is 1.2.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.Decimal> values.  
  
 [!CODE [System.Math.Abs#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than or equal to &lt;xref:System.Double?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.Double?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of a double-precision floating-point number.</summary>
        <returns>A double-precision floating-point number, x, such that 0 ≤ x ≤&lt;xref:System.Double?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a <xref:System.Double> is its numeric value without its sign. For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.  
  
 If  is equal to <xref:System.Double> or <xref:System.Double>, the return value is <xref:System.Double>. If  is equal to <xref:System.Double>, the return value is <xref:System.Double>.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.Double> values.  
  
 [!CODE [System.Math.Abs#2](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than &lt;xref:System.Int16?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.Int16?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of a 16-bit signed integer.</summary>
        <returns>A 16-bit signed integer, x, such that 0 ≤ x ≤&lt;xref:System.Int16?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of an <xref:System.Int16> is its numeric value without its sign. For example, the absolute value of both 123 and -123 is 123.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.Int16> values.  
  
 [!CODE [System.Math.Abs#3](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than &lt;xref:System.Int32?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.Int32?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of a 32-bit signed integer.</summary>
        <returns>A 32-bit signed integer, x, such that 0 ≤ x ≤&lt;xref:System.Int32?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of an <xref:System.Int32> is its numeric value without its sign. For example, the absolute value of both 123 and -123 is 123.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.Int32> values.  
  
 [!CODE [System.Math.Abs#4](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than &lt;xref:System.Int64?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.Int64?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of a 64-bit signed integer.</summary>
        <returns>A 64-bit signed integer, x, such that 0 ≤ x ≤&lt;xref:System.Int64?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of an <xref:System.Int64> is its numeric value without its sign. For example, the absolute value of both 123 and -123 is 123.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.Int64> values.  
  
 [!CODE [System.Math.Abs#5](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than &lt;xref:System.SByte?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.SByte?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of an 8-bit signed integer.</summary>
        <returns>An 8-bit signed integer, x, such that 0 ≤ x ≤&lt;xref:System.SByte?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a signed byte is its numeric value without its sign. For example, the absolute value of both 12 and -12 is 12.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.SByte> values.  
  
 [!CODE [System.Math.Abs#6](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than or equal to &lt;xref:System.Single?displayProperty=fullName&gt;, but less than or equal to &lt;xref:System.Single?displayProperty=fullName&gt;.</param>
        <summary>Returns the absolute value of a single-precision floating-point number.</summary>
        <returns>A single-precision floating-point number, x, such that 0 ≤ x ≤&lt;xref:System.Single?displayProperty=fullName&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a <xref:System.Single> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.  
  
 If  is equal to <xref:System.Single> or <xref:System.Single>, the return value is <xref:System.Single>. If  is equal to <xref:System.Single>, the return value is <xref:System.Single>.  
  
   
  
## Examples  
 The following example uses the Abs method to get the absolute value of a number of <xref:System.Single> values.  
  
 [!CODE [System.Math.Abs#7](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Abs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a cosine, where  must be greater than or equal to -1, but less than or equal to 1.</param>
        <summary>Returns the angle whose cosine is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that 0 ≤θ≤π  
  
 -or-  
  
 &lt;see cref="T:System.Double"&gt; if  \&lt; -1 or  &gt; 1 or  equals &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=fullName> to convert from radians to degrees.  
  
   
  
## Examples  
 The following example uses the Acos method to assist in the computation of the inner angles of a given trapezoid.  
  
 [!CODE [MathSample#1](../CodeSnippet/VS_Snippets_CLR/MathSample#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a sine, where  must be greater than or equal to -1, but less than or equal to 1.</param>
        <summary>Returns the angle whose sine is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2  
  
 -or-  
  
 &lt;see cref="T:System.Double"&gt; if  \&lt; -1 or  &gt; 1 or  equals &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.  
  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=fullName> to convert from radians to degrees.  
  
   
  
## Examples  
 The following example uses Asin to assist in the computation of the inner angles of a given trapezoid.  
  
 [!CODE [MathSample#1](../CodeSnippet/VS_Snippets_CLR/MathSample#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a tangent.</param>
        <summary>Returns the angle whose tangent is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2.  
  
 -or-  
  
 &lt;see cref="T:System.Double"&gt; if  equals &lt;see cref="T:System.Double"&gt;, -π/2 rounded to double precision (-1.5707963267949) if  equals &lt;see cref="T:System.Double"&gt;, or π/2 rounded to double precision (1.5707963267949) if  equals &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.  
  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=fullName> to convert from radians to degrees.  
  
   
  
## Examples  
 The following example demonstrates how to calculate the arctangent of a value and display it to the console.  
  
 [!CODE [math.atanx#1](../CodeSnippet/VS_Snippets_CLR/math.atanx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">The y coordinate of a point.</param>
        <param name="x">The x coordinate of a point.</param>
        <summary>Returns the angle whose tangent is the quotient of two specified numbers.</summary>
        <returns>An angle, θ, measured in radians, such that -π≤θ≤π, and tan(θ) =  / , where (, ) is a point in the Cartesian plane. Observe the following:  
  
-   For (, ) in quadrant 1, 0 &lt; θ &lt; π/2.  
  
-   For (, ) in quadrant 2, π/2 &lt; θ≤π.  
  
-   For (, ) in quadrant 3, -π &lt; θ &lt; -π/2.  
  
-   For (, ) in quadrant 4, -π/2 &lt; θ &lt; 0.  
  
 For points on the boundaries of the quadrants, the return value is the following:  
  
-   If y is 0 and x is not negative, θ = 0.  
  
-   If y is 0 and x is negative, θ = π.  
  
-   If y is positive and x is 0, θ = π/2.  
  
-   If y is negative and x is 0, θ = -π/2.  
  
-   If y is 0 and x is 0, θ = 0.  
  
 If  or  is &lt;see cref="T:System.Double"&gt;, or if  and  are either &lt;see cref="T:System.Double"&gt; or &lt;see cref="T:System.Double"&gt;, the method returns &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).  
  
   
  
## Examples  
 The following example demonstrates how to calculate the arctangent of an angle and a vector. The resulting value is displayed in the console.  
  
 [!CODE [math.atanx#1](../CodeSnippet/VS_Snippets_CLR/math.atanx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a">The first number to multiply.</param>
        <param name="b">The second number to multiply.</param>
        <summary>Produces the full product of two 32-bit numbers.</summary>
        <returns>The number containing the product of the specified numbers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates the use of the BigMul method to calculate the product of two integer values.  
  
 [!CODE [math.bigmul#1](../CodeSnippet/VS_Snippets_CLR/math.bigmul#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number.</param>
        <summary>Returns the smallest integral value that is greater than or equal to the specified decimal number.</summary>
        <returns>The smallest integral value that is greater than or equal to . Note that this method returns a &lt;see cref="T:System.Decimal"&gt; instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward positive infinity. In other words, if  is positive, the presence of any fractional component causes  to be rounded to the next highest integer. If  is negative, the rounding operation causes any fractional component of  to be discarded. The operation of this method differs from the <xref:System.Math.Floor%28System.Decimal%29> method, which supports rounding toward negative infinity.  
  
   
  
## Examples  
 The following example illustrates the Ceiling method and contrasts it with the <xref:System.Math.Floor%28System.Decimal%29> method.  
  
 [!CODE [System.Math.Ceiling#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Ceiling#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">A double-precision floating-point number.</param>
        <summary>Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</summary>
        <returns>The smallest integral value that is greater than or equal to . If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt;, or &lt;see cref="T:System.Double"&gt;, that value is returned. Note that this method returns a &lt;see cref="T:System.Double"&gt; instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward positive infinity. In other words, if  is positive, the presence of any fractional component causes  to be rounded to the next highest integer. If  is negative, the rounding operation causes any fractional component of  to be discarded. The operation of this method differs from the <xref:System.Math.Floor%28System.Double%29> method, which supports rounding toward negative infinity.  
  
   
  
## Examples  
 The following example illustrates the Ceiling method and contrasts it with the <xref:System.Math.Floor%28System.Double%29> method.  
  
 [!CODE [System.Math.Ceiling#2](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Ceiling#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">An angle, measured in radians.</param>
        <summary>Returns the cosine of the specified angle.</summary>
        <returns>The cosine of . If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt;, or &lt;see cref="T:System.Double"&gt;, this method returns &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, , must be in radians. Multiply by <xref:System.Math.PI?displayProperty=fullName>/180 to convert degrees to radians.  
  
 Acceptable values of  range from approximately -9223372036854775295 to approximately 9223372036854775295. For values outside this range, the Cos method returns  unchanged rather than throwing an exception.  
  
   
  
## Examples  
 The following example uses Cos to evaluate certain trigonometric identities for selected angles.  
  
 [!CODE [System.Math.SinCos#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.SinCos#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">An angle, measured in radians.</param>
        <summary>Returns the hyperbolic cosine of the specified angle.</summary>
        <returns>The hyperbolic cosine of . If  is equal to &lt;see cref="T:System.Double"&gt; or &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt; is returned. If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt; is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, , must be in radians. Multiply by <xref:System.Math.PI?displayProperty=fullName>/180 to convert degrees to radians.  
  
   
  
## Examples  
 The following example uses Cosh to evaluate certain hyperbolic identities for selected values.  
  
 [!CODE [System.Math.SinhCosh#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.SinhCosh#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, int32 result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">The dividend.</param>
        <param name="b">The divisor.</param>
        <param name="result">The remainder.</param>
        <summary>Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</summary>
        <returns>The quotient of the specified numbers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The remainder is calculated by using the modulus operation.  
  
   
  
## Examples  
 The following example demonstrates the DivRem method.  
  
 [!CODE [System.Math.DivRem#1](../CodeSnippet/VS_Snippets_CLR_System/system.math.divrem#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, int64 result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">The dividend.</param>
        <param name="b">The divisor.</param>
        <param name="result">The remainder.</param>
        <summary>Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</summary>
        <returns>The quotient of the specified numbers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The remainder is calculated by using the modulus operation.  
  
   
  
## Examples  
 The following example demonstrates the DivRem method.  
  
 [!CODE [System.Math.DivRem#2](../CodeSnippet/VS_Snippets_CLR_System/system.math.divrem#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary>Represents the natural logarithmic base, specified by the constant, `e`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The value of this field is 2.7182818284590452354.  
  
   
  
## Examples  
 The following example compares E with the value calculated from a power series.  
  
 [!CODE [System.Math.E#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.E#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number specifying a power.</param>
        <summary>Returns `e` raised to the specified power.</summary>
        <returns>The number `e` raised to the power . If  equals &lt;see cref="T:System.Double"&gt; or &lt;see cref="T:System.Double"&gt;, that value is returned. If  equals &lt;see cref="T:System.Double"&gt;, 0 is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` is a mathematical constant whose value is approximately 2.71828.  
  
 Use the <xref:System.Math.Pow%2A> method to calculate powers of other bases.  
  
 Exp is the inverse of <xref:System.Math.Log%2A>.  
  
   
  
## Examples  
 The following example uses Exp to evaluate certain exponential and logarithmic identities for selected values.  
  
 [!CODE [System.Math.Exp#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Exp#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number.</param>
        <summary>Returns the largest integer less than or equal to the specified decimal number.</summary>
        <returns>The largest integer less than or equal to .  Note that the method returns an integral value of type &lt;see cref="T:System.Math"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward negative infinity. In other words, if  is positive, any fractional component is truncated. If  is negative, the presence of any fractional component causes it to be rounded to the smaller integer. The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.  
  
   
  
## Examples  
 The following example illustrates the Floor method and contrasts it with the <xref:System.Math.Ceiling%28System.Decimal%29> method.  
  
 [!CODE [System.Math.Ceiling#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Ceiling#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A double-precision floating-point number.</param>
        <summary>Returns the largest integer less than or equal to the specified double-precision floating-point number.</summary>
        <returns>The largest integer less than or equal to . If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt;, or &lt;see cref="T:System.Double"&gt;, that value is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward negative infinity. In other words, if  is positive, any fractional component is truncated. If  is negative, the presence of any fractional component causes it to be rounded to the smaller integer. The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.  
  
   
  
## Examples  
 The following example illustrates the Floor method and contrasts it with the <xref:System.Math.Ceiling%28System.Double%29> method.  
  
 [!CODE [System.Math.Ceiling#2](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Ceiling#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">A dividend.</param>
        <param name="y">A divisor.</param>
        <summary>Returns the remainder resulting from the division of a specified number by another specified number.</summary>
        <returns>A number equal to  - ( Q), where Q is the quotient of  /  rounded to the nearest integer (if  /  falls halfway between two integers, the even integer is returned).  
  
 If  - ( Q) is zero, the value +0 is returned if  is positive, or -0 if  is negative.  
  
 If  = 0, &lt;see cref="T:System.Double"&gt; is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.  
  
 TheIEEERemainder method is not the same as the modulus operator. Although both return the remainder after division, the formulas they use are different. The formula for the IEEERemainder method is:  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 In contrast, the formula for the modulus operator is:  
  
```  
Modulus = (Math.Abs(dividend) - (Math.Abs(divisor) *   
          (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
          Math.Sign(dividend)  
```  
  
   
  
## Examples  
 The following example contrasts the remainder returned by the IEEERemainder method with the remainder returned by the modulus division operator.  
  
 [!CODE [System.Math.IEEERemainder#1](../CodeSnippet/VS_Snippets_CLR_System/system.math.ieeeremainder#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">The number whose logarithm is to be found.</param>
        <summary>Returns the natural (base `e`) logarithm of a specified number.</summary>
        <returns>One of the values in the following table.  
  
|parameter|Return value|  
|---------------|------------------|  
|Positive|The natural logarithm of ; that is, ln , or log e|  
|Zero|&lt;see cref="T:System.Double"&gt;|  
|Negative|&lt;see cref="T:System.Double"&gt;|  
|Equal to &lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|  
|Equal to &lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter  is specified as a base 10 number.  
  
   
  
## Examples  
 The following example illustrates the Log method.  
  
 [!CODE [System.Math.Log_Overloads#2](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Log_Overloads#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">The number whose logarithm is to be found.</param>
        <param name="newBase">The base of the logarithm.</param>
        <summary>Returns the logarithm of a specified number in a specified base.</summary>
        <returns>One of the values in the following table. (+Infinity denotes &lt;see cref="T:System.Double"&gt;, -Infinity denotes &lt;see cref="T:System.Double"&gt;, and NaN denotes &lt;see cref="T:System.Double"&gt;.)  
  
|||Return value|  
|-|-|------------------|  
|&gt; 0|(0 &lt;\&lt; 1) -or-(&gt; 1)|lognewBase(a)|  
|&lt; 0|(any value)|NaN|  
|(any value)|&lt; 0|NaN|  
|!= 1|= 0|NaN|  
|!= 1|= +Infinity|NaN|  
|= NaN|(any value)|NaN|  
|(any value)|= NaN|NaN|  
|(any value)|= 1|NaN|  
|= 0|0 &lt;\&lt; 1|+Infinity|  
|= 0|&gt; 1|-Infinity|  
|=  +Infinity|0 &lt;\&lt; 1|-Infinity|  
|=  +Infinity|&gt; 1|+Infinity|  
|= 1|= 0|0|  
|= 1|= +Infinity|0|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example uses <xref:System.Math.Log%2A> to evaluate certain logarithmic identities for selected values.  
  
 [!CODE [System.Math.Log_Overloads#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Log_Overloads#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number whose logarithm is to be found.</param>
        <summary>Returns the base 10 logarithm of a specified number.</summary>
        <returns>One of the values in the following table.  
  
|parameter|Return value|  
|---------------|------------------|  
|Positive|The base 10 log of ; that is, log 10.|  
|Zero|&lt;see cref="T:System.Double"&gt;|  
|Negative|&lt;see cref="T:System.Double"&gt;|  
|Equal to &lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|  
|Equal to &lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter  is specified as a base 10 number.  
  
   
  
## Examples  
 The following example uses the Log10 method to return the base 10 logarithm for selected values.  
  
 [!CODE [System.Math.Log10#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Log10#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 8-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 8-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two decimal numbers to compare.</param>
        <param name="val2">The second of two decimal numbers to compare.</param>
        <summary>Returns the larger of two decimal numbers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two double-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two double-precision floating-point numbers to compare.</param>
        <summary>Returns the larger of two double-precision floating-point numbers.</summary>
        <returns>Parameter  or , whichever is larger. If , , or both  and  are equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt; is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit signed integers to compare.</param>
        <param name="val2">The second of two 16-bit signed integers to compare.</param>
        <summary>Returns the larger of two 16-bit signed integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit signed integers to compare.</param>
        <param name="val2">The second of two 32-bit signed integers to compare.</param>
        <summary>Returns the larger of two 32-bit signed integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit signed integers to compare.</param>
        <param name="val2">The second of two 64-bit signed integers to compare.</param>
        <summary>Returns the larger of two 64-bit signed integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit signed integers to compare.</param>
        <param name="val2">The second of two 8-bit signed integers to compare.</param>
        <summary>Returns the larger of two 8-bit signed integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two single-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two single-precision floating-point numbers to compare.</param>
        <summary>Returns the larger of two single-precision floating-point numbers.</summary>
        <returns>Parameter  or , whichever is larger. If , or , or both  and  are equal to &lt;see cref="T:System.Single"&gt;, &lt;see cref="T:System.Single"&gt; is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 16-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 16-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 32-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 32-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 64-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 64-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is larger.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.  
  
 [!CODE [Math.Max#1](../CodeSnippet/VS_Snippets_CLR/math.max#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 8-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 8-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two decimal numbers to compare.</param>
        <param name="val2">The second of two decimal numbers to compare.</param>
        <summary>Returns the smaller of two decimal numbers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two double-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two double-precision floating-point numbers to compare.</param>
        <summary>Returns the smaller of two double-precision floating-point numbers.</summary>
        <returns>Parameter  or , whichever is smaller. If , , or both  and  are equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt; is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit signed integers to compare.</param>
        <param name="val2">The second of two 16-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 16-bit signed integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit signed integers to compare.</param>
        <param name="val2">The second of two 32-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 32-bit signed integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit signed integers to compare.</param>
        <param name="val2">The second of two 64-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 64-bit signed integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit signed integers to compare.</param>
        <param name="val2">The second of two 8-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 8-bit signed integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two single-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two single-precision floating-point numbers to compare.</param>
        <summary>Returns the smaller of two single-precision floating-point numbers.</summary>
        <returns>Parameter  or , whichever is smaller. If , , or both  and  are equal to &lt;see cref="T:System.Single"&gt;, &lt;see cref="T:System.Single"&gt; is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 16-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 16-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 32-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 32-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 64-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 64-bit unsigned integers.</summary>
        <returns>Parameter  or , whichever is smaller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.  
  
 [!CODE [Math.Min#1](../CodeSnippet/VS_Snippets_CLR/math.min#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary>Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The value of this field is 3.14159265358979323846.  
  
   
  
## Examples  
 The following example uses PI to assist in the computation of the inner angles of a given trapezoid.  
  
 [!CODE [MathSample#1](../CodeSnippet/VS_Snippets_CLR/MathSample#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">A double-precision floating-point number to be raised to a power.</param>
        <param name="y">A double-precision floating-point number that specifies a power.</param>
        <summary>Returns a specified number raised to the specified power.</summary>
        <returns>The number  raised to the power .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The following table indicates the return value when various values or ranges of values are specified for the  and  parameters. For more information, see <xref:System.Double?displayProperty=fullName>, <xref:System.Double?displayProperty=fullName>, and <xref:System.Double?displayProperty=fullName>.  
  
|Parameters|Return value|  
|----------------|------------------|  
|or  = `NaN`.|`NaN`|  
|= Any value except `NaN`;  = 0.|1|  
|= `NegativeInfinity`;  < 0.|0|  
|= `NegativeInfinity`;  is a positive odd integer.|`NegativeInfinity`|  
|= `NegativeInfinity`;  is positive but not an odd integer.|`PositiveInfinity`|  
|< 0 but not `NegativeInfinity`;  is not an integer, `NegativeInfinity`, or `PositiveInfinity`.|`NaN`|  
|= -1;  = `NegativeInfinity` or `PositiveInfinity`.|`NaN`|  
|-1 <  < 1;  = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 <  < 1;  = `PositiveInfinity`.|0|  
|\< -1 or  > 1;  = `NegativeInfinity`.|0|  
|\< -1 or  > 1;  = `PositiveInfinity`.|`PositiveInfinity`|  
|= 0;  < 0.|`PositiveInfinity`|  
|= 0;  > 0.|0|  
|= 1;  is any value except `NaN`.|1|  
|= `PositiveInfinity`;  < 0.|0|  
|= `PositiveInfinity`;  > 0.|`PositiveInfinity`|  
  
   
  
## Examples  
 The following example uses the Pow method to calculate the value that results from raising 2 to a power ranging from 0 to 32.  
  
 [!CODE [System.Math.Pow#1](../CodeSnippet/VS_Snippets_CLR_System/system.math.pow#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <summary>Rounds a decimal value to the nearest integral value.</summary>
        <returns>The integer nearest parameter . If the fractional component of  is halfway between two integers, one of which is even and the other odd, the even number is returned. Note that this method returns a &lt;see cref="T:System.Decimal"&gt; instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">A double-precision floating-point number to be rounded.</param>
        <summary>Rounds a double-precision floating-point value to the nearest integral value.</summary>
        <returns>The integer nearest . If the fractional component of  is halfway between two integers, one of which is even and the other odd, then the even number is returned. Note that this method returns a &lt;see cref="T:System.Double"&gt; instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <param name="decimals">The number of decimal places in the return value.</param>
        <summary>Rounds a decimal value to a specified number of fractional digits.</summary>
        <returns>The number nearest to  that contains a number of fractional digits equal to .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <param name="mode">Specification for how to round  if it is midway between two other numbers.</param>
        <summary>Rounds a decimal value to the nearest integer. A parameter specifies how to round the value if it is midway between two numbers.</summary>
        <returns>The integer nearest . If  is halfway between two numbers, one of which is even and the other odd, then  determines which of the two is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A double-precision floating-point number to be rounded.</param>
        <param name="digits">The number of fractional digits in the return value.</param>
        <summary>Rounds a double-precision floating-point value to a specified number of fractional digits.</summary>
        <returns>The number nearest to  that contains a number of fractional digits equal to .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">A double-precision floating-point number to be rounded.</param>
        <param name="mode">Specification for how to round  if it is midway between two other numbers.</param>
        <summary>Rounds a double-precision floating-point value to the nearest integer. A parameter specifies how to round the value if it is midway between two numbers.</summary>
        <returns>The integer nearest . If  is halfway between two integers, one of which is even and the other odd, then  determines which of the two is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <param name="decimals">The number of decimal places in the return value.</param>
        <param name="mode">Specification for how to round  if it is midway between two other numbers.</param>
        <summary>Rounds a decimal value to a specified number of fractional digits. A parameter specifies how to round the value if it is midway between two numbers.</summary>
        <returns>The number nearest to  that contains a number of fractional digits equal to . If  has fewer fractional digits than ,  is returned unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">A double-precision floating-point number to be rounded.</param>
        <param name="digits">The number of fractional digits in the return value.</param>
        <param name="mode">Specification for how to round  if it is midway between two other numbers.</param>
        <summary>Rounds a double-precision floating-point value to a specified number of fractional digits. A parameter specifies how to round the value if it is midway between two numbers.</summary>
        <returns>The number nearest to  that has a number of fractional digits equal to . If  has fewer fractional digits than ,  is returned unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">A signed decimal number.</param>
        <summary>Returns an integer that indicates the sign of a decimal number.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of a <xref:System.Decimal> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a double-precision floating-point number.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of a <xref:System.Double> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a 16-bit signed integer.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of an <xref:System.Int16> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a 32-bit signed integer.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of an <xref:System.Int32> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a 64-bit signed integer.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of an <xref:System.Int64> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of an 8-bit signed integer.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of an <xref:System.SByte> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a single-precision floating-point number.</summary>
        <returns>A number that indicates the sign of , as shown in the following table.  
  
|Return value|Meaning|  
|------------------|-------------|  
|-1|is less than zero.|  
|0|is equal to zero.|  
|1|is greater than zero.|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the Sign method to determine the sign of a <xref:System.Single> value and display it to the console.  
  
 [!CODE [Math.Sign#1](../CodeSnippet/VS_Snippets_CLR/math.sign#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">An angle, measured in radians.</param>
        <summary>Returns the sine of the specified angle.</summary>
        <returns>The sine of . If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt;, or &lt;see cref="T:System.Double"&gt;, this method returns &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, , must be in radians. Multiply by <xref:System.Math.PI?displayProperty=fullName>/180 to convert degrees to radians.  
  
 Acceptable values of  range from approximately -9223372036854775295 to approximately 9223372036854775295. For values outside of this range, the Sin method returns  unchanged rather than throwing an exception.  
  
   
  
## Examples  
 The following example uses Sin to evaluate certain trigonometric identities for selected angles.  
  
 [!CODE [System.Math.SinCos#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.SinCos#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">An angle, measured in radians.</param>
        <summary>Returns the hyperbolic sine of the specified angle.</summary>
        <returns>The hyperbolic sine of . If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt;, or &lt;see cref="T:System.Double"&gt;, this method returns a &lt;see cref="T:System.Double"&gt; equal to .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, , must be in radians. Multiply by <xref:System.Math.PI?displayProperty=fullName>/180 to convert degrees to radians.  
  
   
  
## Examples  
 The following example uses Sinh to evaluate certain hyperbolic identities for selected values.  
  
 [!CODE [System.Math.SinhCosh#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.SinhCosh#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">The number whose square root is to be found.</param>
        <summary>Returns the square root of a specified number.</summary>
        <returns>One of the values in the following table.  
  
|parameter|Return value|  
|---------------|------------------|  
|Zero or positive|The positive square root of .|  
|Negative|&lt;see cref="T:System.Double"&gt;|  
|Equals &lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|  
|Equals &lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The square root of the area of a square represents the length of any side of the square. The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.  
  
 [!CODE [System.Math.Sqrt#1](../CodeSnippet/VS_Snippets_CLR_System/system.math.sqrt#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">An angle, measured in radians.</param>
        <summary>Returns the tangent of the specified angle.</summary>
        <returns>The tangent of . If  is equal to &lt;see cref="T:System.Double"&gt;, &lt;see cref="T:System.Double"&gt;, or &lt;see cref="T:System.Double"&gt;, this method returns &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, , must be in radians. Multiply by <xref:System.Math.PI?displayProperty=fullName>/180 to convert degrees to radians.  
  
   
  
## Examples  
 The following example demonstrates how to calculate the tangent of an angle and display it to the console.  
  
 [!CODE [math.atanx#1](../CodeSnippet/VS_Snippets_CLR/math.atanx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">An angle, measured in radians.</param>
        <summary>Returns the hyperbolic tangent of the specified angle.</summary>
        <returns>The hyperbolic tangent of . If  is equal to &lt;see cref="T:System.Double"&gt;, this method returns -1. If value is equal to &lt;see cref="T:System.Double"&gt;, this method returns 1. If  is equal to &lt;see cref="T:System.Double"&gt;, this method returns &lt;see cref="T:System.Double"&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, , must be in radians. Multiply by <xref:System.Math.PI?displayProperty=fullName>/180 to convert degrees to radians.  
  
   
  
## Examples  
 The following example uses Tanh to evaluate certain hyperbolic tangent identities for selected values.  
  
 [!CODE [System.Math.Tanh#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Tanh#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">A number to truncate.</param>
        <summary>Calculates the integral part of a specified decimal number.</summary>
        <returns>The integral part of ; that is, the number that remains after any fractional digits have been discarded.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Truncate rounds  to the nearest integer towards zero.  
  
   
  
## Examples  
 The following example calls the Truncate method to truncate both a positive and a negative <xref:System.Decimal> value.  
  
 [!CODE [System.Math.Truncate#2](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Truncate#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number to truncate.</param>
        <summary>Calculates the integral part of a specified double-precision floating-point number.</summary>
        <returns>The integral part of ; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.  
  
||Return value|  
|-|------------------|  
|&lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|  
|&lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|  
|&lt;see cref="T:System.Double"&gt;|&lt;see cref="T:System.Double"&gt;|</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Truncate rounds  to the nearest integer towards zero.  
  
   
  
## Examples  
 The following example calls the Truncate method to truncate both a positive and a negative <xref:System.Double> value.  
  
 [!CODE [System.Math.Truncate#1](../CodeSnippet/VS_Snippets_CLR_System/system.Math.Truncate#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>