<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Exposes a file within isolated storage.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this class to read, write and create files in isolated storage.  
  
 Since this class extends <xref:System.IO.FileStream>, you can use an instance of IsolatedStorageFileStream in most situations where a <xref:System.IO.FileStream> might otherwise be used, such as to construct a <xref:System.IO.StreamReader> or <xref:System.IO.StreamWriter>.  
  
 This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  
  
> [!IMPORTANT]
>  Isolated storage is not available for [!INCLUDE[win8_appname_long](../../add/includes/win8-appname-long-md.md)] apps. Instead, use the application data classes in the `Windows.Storage` namespaces included in the [!INCLUDE[wrt](../../add/includes/wrt-md.md)] API to store local data and files. For more information, see [Application data](http://go.microsoft.com/fwlink/?LinkId=229175) in the Windows Dev Center.  
  
   
  
## Examples  
 The following console application demonstrates how you can use <xref:System.IO.IsolatedStorage.IsolatedStorageFile> and IsolatedStorageFileStream to write data to an Isolated Storage file. The user is requested to log in. If the user is a new user, a News URL and a Sports URL are recorded as personal preferences in Isolated Storage. If the user is a returning user, the user's current preferences are displayed. The code examples used throughout this namespace are presented in the context of this sample application. You can use the [Storeadm.exe (Isolated Storage Tool)](../Topic/Storeadm.exe%20\(Isolated%20Storage%20Tool\).md) utility to list and remove the Isolated Storage files that are created with this console application.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#1](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <summary>Initializes a new instance of an &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object giving access to the file designated by  in the specified .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The isolated store that is used is scoped by the current executing assembly's identity and that of the application domain in which it is running. This store will remain open only for the lifetime of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. To specify a different isolated storage scope, or to allow the store to remain open (so multiple <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objects can be opened from it), use the form of the constructor that accepts an <xref:System.IO.IsolatedStorage.IsolatedStorageFile> object.  
  
 The  parameter indicates whether a new file should be created, an existing one used, and so on.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable and can cause an exception to be thrown.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="access">A bitwise combination of the &lt;see cref="T:System.IO.FileAccess"&gt; values.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by , in the specified , with the kind of  requested.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The isolated store that is used is scoped by the current executing assembly's identity and that of the application domain in which it is running. This store will remain open only for the lifetime of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. To specify a different isolated storage scope, or to allow the store to remain open (so multiple <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objects can be opened from it), use the form of the constructor that accepts an <xref:System.IO.IsolatedStorage.IsolatedStorageFile> object.  
  
 The  parameter indicates whether a new file should be created or an existing one used. The  parameter includes read-only, read/write, and write-only.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and can cause an exception to be thrown.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="isf">The &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"&gt; in which to open the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream&gt;.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by , in the specified , and in the context of the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFile&gt; specified by .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The  parameter indicates whether a new file should be created, an existing one used, and so on.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and can cause an exception to be thrown.  
  
   
  
## Examples  
 The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#11](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="access">A bitwise combination of the &lt;see cref="T:System.IO.FileAccess"&gt; values.</param>
        <param name="share">A bitwise combination of the &lt;see cref="T:System.IO.FileShare"&gt; values.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The isolated store that is used is scoped by the current executing assembly's identity and that of the application domain in which it is running. This store will remain open only for the lifetime of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. To specify a different isolated storage scope, or to allow the store to remain open (so multiple <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objects can be opened from it), use the form of the constructor that accepts an <xref:System.IO.IsolatedStorage.IsolatedStorageFile> object.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable and can cause an exception to be thrown.  
  
   
  
## Examples  
 The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#15](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="access">A bitwise combination of the &lt;see cref="T:System.IO.FileAccess"&gt; values.</param>
        <param name="isf">The &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"&gt; in which to open the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream&gt;.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by  in the specified , with the specified file , and in the context of the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFile&gt; specified by .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The  parameter indicates whether a new file should be created or an existing one used. The  parameter includes read-only, read/write, and write-only.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and can cause an exception to be thrown.  
  
   
  
## Examples  
 The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#10](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="access">A bitwise combination of the &lt;see cref="T:System.IO.FileAccess"&gt; values.</param>
        <param name="share">A bitwise combination of the &lt;see cref="T:System.IO.FileShare"&gt; values.</param>
        <param name="bufferSize">The &lt;see cref="T:System.IO.FileStream"&gt; buffer size.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by , with the  specified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The isolated store that is used is scoped by the current executing assembly's identity and that of the application domain in which it is running. This store will remain open only for the lifetime of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. To specify a different isolated storage scope, or to allow the store to remain open (so multiple <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objects can be opened from it), use the form of the constructor that accepts an <xref:System.IO.IsolatedStorage.IsolatedStorageFile> object.  
  
 The  parameter indicates whether a new file should be created or an existing one used. The  parameter includes read-only, read/write, and write-only.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and can cause an exception to be thrown.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="access">A bitwise combination of the &lt;see cref="T:System.IO.FileAccess"&gt; values.</param>
        <param name="share">A bitwise combination of the &lt;see cref="T:System.IO.FileShare"&gt; values.</param>
        <param name="isf">The &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"&gt; in which to open the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream&gt;.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by , and in the context of the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFile&gt; specified by .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The  parameter indicates whether a new file should be created or an existing one used. The  parameter includes read-only, read/write, and write-only.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and can cause an exception to be thrown.  
  
   
  
## Examples  
 The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#11](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">The relative path of the file within isolated storage.</param>
        <param name="mode">One of the &lt;see cref="T:System.IO.FileMode"&gt; values.</param>
        <param name="access">A bitwise combination of the &lt;see cref="T:System.IO.FileAccess"&gt; values.</param>
        <param name="share">A bitwise combination of the &lt;see cref="T:System.IO.FileShare"&gt; values</param>
        <param name="bufferSize">The &lt;see cref="T:System.IO.FileStream"&gt; buffer size.</param>
        <param name="isf">The &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"&gt; in which to open the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream&gt;.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by , with the  specified, and in the context of the &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFile&gt; specified by .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The  parameter indicates whether a new file should be created or an existing one used. The  parameter includes read-only, read/write, and write-only.  
  
> [!CAUTION]
>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and can cause an exception to be thrown.  
  
   
  
## Examples  
 The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#12](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to read data into.</param>
        <param name="offset">The byte offset in  at which to begin reading.</param>
        <param name="numBytes">The maximum number of bytes to read.</param>
        <param name="userCallback">The method to call when the asynchronous read operation is completed. This parameter is optional.</param>
        <param name="stateObject">The status of the asynchronous read.</param>
        <summary>Begins an asynchronous read.</summary>
        <returns>An &lt;see cref="T:System.IAsyncResult"&gt; object that represents the asynchronous read, which is possibly still pending. This &lt;see cref="T:System.IAsyncResult"&gt; must be passed to this stream's &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A&gt; method to determine how many bytes were read. This can be done either by the same code that called BeginRead or in a callback passed to BeginRead.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes.  
  
 You must call <xref:System.IO.Stream.EndRead%2A> with this <xref:System.IAsyncResult> to find out how many bytes were read.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to write data to.</param>
        <param name="offset">The byte offset in  at which to begin writing.</param>
        <param name="numBytes">The maximum number of bytes to write.</param>
        <param name="userCallback">The method to call when the asynchronous write operation is completed. This parameter is optional.</param>
        <param name="stateObject">The status of the asynchronous write.</param>
        <summary>Begins an asynchronous write.</summary>
        <returns>An &lt;see cref="T:System.IAsyncResult"&gt; that represents the asynchronous write, which is possibly still pending. This &lt;see cref="T:System.IAsyncResult"&gt; must be passed to this stream's &lt;xref:System.IO.Stream.EndWrite%2A&gt; method to ensure that the write is complete, then frees resources appropriately. This can be done either by the same code that called &lt;xref:System.IO.Stream.BeginWrite%2A&gt; or in a callback passed to &lt;xref:System.IO.Stream.BeginWrite%2A&gt;.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If a <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object is writable, writing at the end of the stream expands the stream.  
  
 The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes.  
  
 You must call <xref:System.IO.Stream.EndWrite%2A> with the <xref:System.IAsyncResult> object that this method returns to find out how many bytes were written.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value indicating whether the file can be read.</summary>
        <value>`true` if an &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object can be read; otherwise, `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this property to determine whether the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object can be read.  
  
   
  
## Examples  
 The following code example demonstrates how you could use the CanRead property, as a check to see whether a stream can be read before calling the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> or <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> methods. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#11](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value indicating whether seek operations are supported.</summary>
        <value>`true` if an &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object supports seek operations; otherwise, `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this property to determine whether the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object supports seek operations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value indicating whether you can write to the file.</summary>
        <value>`true` if an &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object can be written; otherwise, `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this property to determine whether the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object can be written.  
  
   
  
## Examples  
 The following code example demonstrates how you could use the CanWrite property, as a check to see whether a stream can be read before calling the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> or <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> methods. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#13](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources</param>
        <summary>Releases the unmanaged resources used by the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is called by the public <xref:System.IDisposable.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method. <xref:System.IDisposable.Dispose%2A> invokes the protected Dispose method with the  parameter set to true. <xref:System.Object.Finalize%2A> invokes Dispose with  set to false.  
  
 When the  parameter is true, this method releases all resources held by any managed objects that this <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> references. This method invokes the <xref:System.IDisposable.Dispose%2A> method of each referenced object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending asynchronous request.</param>
        <summary>Ends a pending asynchronous read request.</summary>
        <returns>The number of bytes read from the stream, between zero and the number of requested bytes. Streams will only return zero at the end of the stream. Otherwise, they will block until at least one byte is available.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 EndRead must be called exactly once on every <xref:System.IAsyncResult> object from <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, and calling EndRead is the only way to know how many bytes were read from the <xref:System.IO.Stream>. EndRead will block until the I/O operation has completed.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending asynchronous I/O request to end.</param>
        <summary>Ends an asynchronous write.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 EndWrite must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 EndWrite will block until the I/O operation has completed.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears buffers for this stream and causes any buffered data to be written to the file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Because a buffer can be used for either reading or writing, but not both simultaneously, Flush performs two functions. First, any data previously written to the buffer is copied to the file and the buffer is cleared. Second, if <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> is `true` and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer. The buffer is then cleared.  
  
 Use the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">`true` to flush all intermediate file buffers; otherwise, `false`.</param>
        <summary>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use IsolatedStorageFileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the file handle for the file that the current &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object encapsulates. Accessing this property is not permitted on an &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object, and throws an &lt;xref:System.IO.IsolatedStorage.IsolatedStorageException&gt;.</summary>
        <value>The file handle for the file that the current &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object encapsulates.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For more information, see <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 The following code example demonstrates the Handle property.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#4](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value indicating whether the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object was opened asynchronously or synchronously.</summary>
        <value>`true` if the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object supports asynchronous access; otherwise, `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchronous <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objects cannot be created, unlike <xref:System.IO.FileStream>. However, the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, and <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> methods are supported on synchronous instances, with some performance penalties.  
  
   
  
## Examples  
 The following code example demonstrates how you can use the IsAsync property to verify that an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> is synchronous. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#7](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</summary>
        <value>The length of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Length represents the number of bytes currently in the file. It is not affected by isolated storage quota.  
  
   
  
## Examples  
 The following code example demonstrates the Length property.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#14](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">The starting position of the range to lock. The value of this parameter must be equal to or greater than 0 (zero).</param>
        <param name="length">The number of bytes to lock.</param>
        <summary>Prevents other processes from reading from or writing to the stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position of the current &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</summary>
        <value>The current position of this &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Setting this property works when the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> property is `true`.  
  
   
  
## Examples  
 The following code example uses the Position property to write data to a file.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#14](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to read.</param>
        <param name="offset">The offset in the buffer at which to begin writing.</param>
        <param name="count">The maximum number of bytes to read.</param>
        <summary>Copies bytes from the current buffered &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object to an array.</summary>
        <returns>The total number of bytes read into the . This can be less than the number of bytes requested if that many bytes are not currently available, or zero if the end of the stream is reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The  parameter can be an instance of the <xref:System.Buffer> class, or an array of one of the following types: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double>. The  parameter gives the offset of the byte in buffer at which to begin writing (index in the buffer), and the  parameter gives the maximum number of bytes that will be read from this stream. The returned value is the actual number of bytes read, or zero if the end of the stream is reached. If the read operation is successful, the current position of the stream is advanced by the number of bytes read. If an exception occurs, the current position of the stream is unchanged.  
  
 The Read method treats the  parameter as a block of bytes, regardless of its actual type. Likewise, the  and  parameters are always specified in bytes. For  parameters other than byte arrays, this means that an element index must be multiplied by the element size in bytes to form a correct value for  or .  
  
 The Read method will return zero only if the end of the stream is reached. In all other cases, Read always reads at least one byte from the stream before returning. If no data is available from the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object upon a call to Read, the method will block until at least one byte of data can be returned.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads a single byte from the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object in isolated storage.</summary>
        <returns>The 8-bit unsigned integer value read from the isolated storage file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example demonstrates how the ReadByte method can be used to read data from an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#14](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a &lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle"&gt; object that represents the operating system file handle for the file that the current &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream&gt; object encapsulates.</summary>
        <value>A &lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle"&gt; object that represents the operating system file handle for the file that the current &lt;xref:System.IO.IsolatedStorage.IsolatedStorageFileStream&gt; object encapsulates.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The SafeFileHandle property is not supported and always generates an <xref:System.IO.IsolatedStorage.IsolatedStorageException> exception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">The new position of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</param>
        <param name="origin">One of the &lt;see cref="T:System.IO.SeekOrigin"&gt; values.</param>
        <summary>Sets the current position of this &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object to the specified value.</summary>
        <returns>The new position in the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Some <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objects support positioning beyond the length of the stream, others will throw an exception in this case.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The new length of the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</param>
        <summary>Sets the length of this &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object to the specified .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the specified  is less than the current length of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object, the stream is truncated. If the specified  is larger than the current length of the stream, the stream is expanded. If the stream is expanded, the contents of the stream between the old and the new length are undefined. In order to use this method, an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object must support both writing and seeking.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">The starting position of the range to unlock. The value of this parameter must be equal to or greater than 0 (zero).</param>
        <param name="length">The number of bytes to unlock.</param>
        <summary>Allows other processes to access all or part of a file that was previously locked.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to write.</param>
        <param name="offset">The byte offset in buffer from which to begin.</param>
        <param name="count">The maximum number of bytes to write.</param>
        <summary>Writes a block of bytes to the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object using data read from a byte array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The  parameter gives the offset of the byte in the  at which to begin reading, and the  parameter gives the number of bytes that will be written to this <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. If the write operation is successful, the current position of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object is advanced by the number of bytes written. If an exception occurs, the current position of the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object is unchanged.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte value to write to the isolated storage file.</param>
        <summary>Writes a single byte to the &lt;see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"&gt; object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example demonstrates how the WriteByte method can be used to read data from an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  
  
 [!CODE [System.IO.IsolatedStorage.IsolatedStorage#14](../CodeSnippet/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>