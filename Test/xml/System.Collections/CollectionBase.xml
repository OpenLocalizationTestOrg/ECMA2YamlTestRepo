<Type Name="CollectionBase" FullName="System.Collections.CollectionBase">
  <TypeSignature Language="C#" Value="public abstract class CollectionBase : System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CollectionBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides the `abstract` base class for a strongly typed collection.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A CollectionBase instance is always modifiable. See <xref:System.Collections.ReadOnlyCollectionBase> for a read-only version of this class.  
  
 The capacity of a CollectionBase is the number of elements the CollectionBase can hold. As elements are added to a CollectionBase, the capacity is automatically increased as required through reallocation. The capacity can be decreased by setting the <xref:System.Collections.CollectionBase.Capacity%2A> property explicitly.  
  
   
  
## Examples  
 The following code example implements the CollectionBase class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CollectionBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the &lt;see cref="T:System.Collections.CollectionBase"&gt; class with the default initial capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The capacity of a <xref:System.Collections.CollectionBase> is the number of elements that the <xref:System.Collections.CollectionBase> can hold. As elements are added to a <xref:System.Collections.CollectionBase>, the capacity is automatically increased as required by reallocating the internal array.  
  
 If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.CollectionBase>.  
  
 This constructor is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CollectionBase (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The number of elements that the new list can initially store.</param>
        <summary>Initializes a new instance of the &lt;see cref="T:System.Collections.CollectionBase"&gt; class with the specified capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The capacity of a <xref:System.Collections.CollectionBase> is the number of elements that the <xref:System.Collections.CollectionBase> can hold. As elements are added to a <xref:System.Collections.CollectionBase>, the capacity is automatically increased as required by reallocating the internal array.  
  
 If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.CollectionBase>.  
  
 This constructor is an O() operation, where  is .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of elements that the &lt;see cref="T:System.Collections.CollectionBase"&gt; can contain.</summary>
        <value>The number of elements that the &lt;see cref="T:System.Collections.CollectionBase"&gt; can contain.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacity is the number of elements that the <xref:System.Collections.CollectionBase> can store. <xref:System.Collections.CollectionBase.Count%2A> is the number of elements that are actually in the <xref:System.Collections.CollectionBase>.  
  
 Capacity is always greater than or equal to <xref:System.Collections.CollectionBase.Count%2A>. If <xref:System.Collections.CollectionBase.Count%2A> exceeds Capacity while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.  
  
 The capacity can be decreased by setting the Capacity property explicitly. When the value of Capacity is set explicitly, the internal array is also reallocated to accommodate the specified capacity.  
  
 Retrieving the value of this property is an O(1) operation; setting the property is an O() operation, where  is the new capacity.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all objects from the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance. This method cannot be overridden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.CollectionBase.Count%2A> is set to zero.  
  
 This method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
 To perform custom actions before or after the collection is cleared, override the protected <xref:System.Collections.CollectionBase.OnClear%2A> or <xref:System.Collections.CollectionBase.OnClearComplete%2A> method.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance. This property cannot be overridden.</summary>
        <value>The number of elements contained in the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.  
  
 Retrieving the value of this property is an O(1) operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <returns>An &lt;see cref="T:System.Collections.IEnumerator"&gt; for the &lt;xref:System.Collections.CollectionBase&gt; instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 The `foreach` statement of the C# language (`for each` in Visual Basic) hides the complexity of the enumerators.  Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.  
  
 Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.  
  
 Initially, the enumerator is positioned before the first element in the collection. <xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position. At this position, calling <xref:System.Collections.IEnumerator.Current%2A> throws an exception. Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called. <xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.  
  
 If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`. When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`. If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, calling <xref:System.Collections.IEnumerator.Current%2A> throws an exception. To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> throws an <xref:System.InvalidOperationException>. If the collection is modified between <xref:System.Collections.IEnumerator.MoveNext%2A> and <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> returns the element that it is set to, even if the enumerator is already invalidated.  
  
 The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.  
  
 While the GetEnumerator method is not visible to COM clients by default, inheriting the <xref:System.Collections.CollectionBase> class can expose it and can cause undesirable behavior in COM clients.  
  
 This method is an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerList">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList InnerList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList InnerList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an &lt;see cref="T:System.Collections.ArrayList"&gt; containing the list of elements in the &lt;xref:System.Collections.CollectionBase&gt; instance.</summary>
        <value>An &lt;see cref="T:System.Collections.ArrayList"&gt; representing the &lt;xref:System.Collections.CollectionBase&gt; instance itself.  
  
 Retrieving the value of this property is an O(1) operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the InnerList property.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="protected System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an &lt;see cref="T:System.Collections.IList"&gt; containing the list of elements in the &lt;xref:System.Collections.CollectionBase&gt; instance.</summary>
        <value>An &lt;see cref="T:System.Collections.IList"&gt; representing the &lt;xref:System.Collections.CollectionBase&gt; instance itself.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The On* methods are invoked only on the instance returned by the List property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 Retrieving the value of this property is an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClear">
      <MemberSignature Language="C#" Value="protected virtual void OnClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClear() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Performs additional custom processes when clearing the contents of the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action before the collection is cleared.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 If the process fails, the collection reverts back to its previous state.  
  
 The default implementation of this method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClearComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnClearComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClearComplete() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Performs additional custom processes after clearing the contents of the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action after the collection is cleared.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 The default implementation of this method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInsert">
      <MemberSignature Language="C#" Value="protected virtual void OnInsert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsert(int32 index, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which to insert .</param>
        <param name="value">The new value of the element at .</param>
        <summary>Performs additional custom processes before inserting a new element into the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is inserted.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 If the process fails, the collection reverts back to its previous state.  
  
 The default implementation of this method is an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInsertComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInsertComplete (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsertComplete(int32 index, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which to insert .</param>
        <param name="value">The new value of the element at .</param>
        <summary>Performs additional custom processes after inserting a new element into the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is inserted.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 The collection reverts back to its previous state if one of the following occurs:  
  
-   The process fails.  
  
-   This method is overridden to throw an exception.  
  
 The default implementation of this method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemove">
      <MemberSignature Language="C#" Value="protected virtual void OnRemove (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemove(int32 index, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which  can be found.</param>
        <param name="value">The value of the element to remove from .</param>
        <summary>Performs additional custom processes when removing an element from the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is removed.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 If the process fails, the collection reverts back to its previous state.  
  
 The default implementation of this method is an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveComplete (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveComplete(int32 index, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which  can be found.</param>
        <param name="value">The value of the element to remove from .</param>
        <summary>Performs additional custom processes after removing an element from the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is removed.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 The collection reverts back to its previous state if one of the following occurs:  
  
-   The process fails.  
  
-   This method is overridden to throw an exception.  
  
 The default implementation of this method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSet">
      <MemberSignature Language="C#" Value="protected virtual void OnSet (int index, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSet(int32 index, object oldValue, object newValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which  can be found.</param>
        <param name="oldValue">The value to replace with .</param>
        <param name="newValue">The new value of the element at .</param>
        <summary>Performs additional custom processes before setting a value in the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is set.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 If the process fails, the collection reverts back to its previous state.  
  
 The default implementation of this method is an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSetComplete (int index, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetComplete(int32 index, object oldValue, object newValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which  can be found.</param>
        <param name="oldValue">The value to replace with .</param>
        <param name="newValue">The new value of the element at .</param>
        <summary>Performs additional custom processes after setting a value in the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is set.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 The collection reverts back to its previous state if one of the following occurs:  
  
-   The process fails.  
  
-   This method is overridden to throw an exception.  
  
 The default implementation of this method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnValidate">
      <MemberSignature Language="C#" Value="protected virtual void OnValidate (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidate(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to validate.</param>
        <summary>Performs additional custom processes when validating a value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation of this method determines whether  is `null`, and, if so, throws <xref:System.ArgumentNullException>. It is intended to be overridden by a derived class to perform additional action when the specified element is validated.  
  
 The On* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.  
  
 The default implementation of this method is an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to remove.</param>
        <summary>Removes the element at the specified index of the &lt;see cref="T:System.Collections.CollectionBase"&gt; instance. This method is not overridable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot. If the collection is indexed, the indexes of the elements that are moved are also updated. This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.  
  
 This method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional &lt;see cref="T:System.Array"&gt; that is the destination of the elements copied from &lt;xref:System.Collections.CollectionBase&gt;. The &lt;see cref="T:System.Array"&gt; must have zero-based indexing.</param>
        <param name="index">The zero-based index in  at which copying begins.</param>
        <summary>Copies the entire &lt;see cref="T:System.Collections.CollectionBase"&gt; to a compatible one-dimensional &lt;xref:System.Array&gt;, starting at the specified index of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The specified array must be of a compatible type.  
  
 This method uses <xref:System.Array.Copy%2A?displayProperty=fullName> to copy the elements.  
  
 This method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the &lt;see cref="T:System.Collections.CollectionBase"&gt; is synchronized (thread safe).</summary>
        <value>`true` if access to the &lt;see cref="T:System.Collections.CollectionBase"&gt; is synchronized (thread safe); otherwise, `false`. The default is `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Collections.CollectionBase> instance is not synchronized. Derived classes can provide a synchronized version of the <xref:System.Collections.CollectionBase> using the <xref:System.Collections.ICollection.SyncRoot%2A> property.  
  
 Enumerating through a collection is intrinsically not a thread safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.  
  
 The following code example shows how to lock the collection using the <xref:System.Collections.ICollection.SyncRoot%2A> during the entire enumeration:  
  
 [!CODE [System.Collections.CollectionBase#2](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#2)]  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the &lt;see cref="T:System.Collections.CollectionBase"&gt;.</summary>
        <value>An object that can be used to synchronize access to the &lt;see cref="T:System.Collections.CollectionBase"&gt;.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derived classes can provide their own synchronized version of the <xref:System.Collections.CollectionBase> using the <xref:System.Collections.ICollection.SyncRoot%2A> property. The synchronizing code must perform operations on the <xref:System.Collections.ICollection.SyncRoot%2A> of the <xref:System.Collections.CollectionBase>, not directly on the <xref:System.Collections.CollectionBase>. This ensures proper operation of collections that are derived from other objects. Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <xref:System.Collections.CollectionBase> object.  
  
 Enumerating through a collection is intrinsically not a thread safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.  
  
 The following code example shows how to lock the collection using the <xref:System.Collections.ICollection.SyncRoot%2A> during the entire enumeration:  
  
 [!CODE [System.Collections.CollectionBase#2](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#2)]  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The &lt;see cref="T:System.Object"&gt; to be added to the end of the &lt;xref:System.Collections.CollectionBase&gt;.</param>
        <summary>Adds an object to the end of the &lt;see cref="T:System.Collections.CollectionBase"&gt;.</summary>
        <returns>The &lt;see cref="T:System.Collections.CollectionBase"&gt; index at which the  has been added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If <xref:System.Collections.CollectionBase.Count%2A> already equals the capacity, the capacity of the list is doubled by automatically reallocating the internal array and copying the existing elements to the new array before the new element is added.  
  
 If <xref:System.Collections.CollectionBase.Count%2A> is less than the capacity, this method is an O(1) operation. If the capacity needs to be increased to accommodate the new element, this method becomes an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The &lt;see cref="T:System.Object"&gt; to locate in the &lt;xref:System.Collections.CollectionBase&gt;.</param>
        <summary>Determines whether the &lt;see cref="T:System.Collections.CollectionBase"&gt; contains a specific element.</summary>
        <returns>`true` if the &lt;see cref="T:System.Collections.CollectionBase"&gt; contains the specified ; otherwise, `false`.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs a linear search; therefore, this method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
 This method determines equality by calling <xref:System.Object.Equals%2A?displayProperty=fullName>.  
  
 Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods on  to determine whether  exists. In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the  parameter on the objects in the collection.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The &lt;see cref="T:System.Object"&gt; to locate in the &lt;xref:System.Collections.CollectionBase&gt;.</param>
        <summary>Searches for the specified &lt;see cref="T:System.Object"&gt; and returns the zero-based index of the first occurrence within the entire &lt;xref:System.Collections.CollectionBase&gt;.</summary>
        <returns>The zero-based index of the first occurrence of  within the entire &lt;see cref="T:System.Collections.CollectionBase"&gt;, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs a linear search; therefore, this method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
 This method determines equality by calling <xref:System.Object.Equals%2A?displayProperty=fullName>.  
  
 Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods on  to determine whether  exists. In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the  parameter on the objects in the collection.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which  should be inserted.</param>
        <param name="value">The &lt;see cref="T:System.Object"&gt; to insert.</param>
        <summary>Inserts an element into the &lt;see cref="T:System.Collections.CollectionBase"&gt; at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If <xref:System.Collections.CollectionBase.Count%2A> already equals the capacity, the capacity of the list is doubled by automatically reallocating the internal array before the new element is inserted.  
  
 If  is equal to <xref:System.Collections.CollectionBase.Count%2A>,  is added to the end of <xref:System.Collections.CollectionBase>.  
  
 In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element. If the collection is indexed, the indexes of the elements that are moved are also updated. This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.  
  
 This method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the &lt;see cref="T:System.Collections.CollectionBase"&gt; has a fixed size.</summary>
        <value>`true` if the &lt;see cref="T:System.Collections.CollectionBase"&gt; has a fixed size; otherwise, `false`. The default is `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.  
  
 A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the &lt;see cref="T:System.Collections.CollectionBase"&gt; is read-only.</summary>
        <value>`true` if the &lt;see cref="T:System.Collections.CollectionBase"&gt; is read-only; otherwise, `false`. The default is `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.  
  
 A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to get or set.</param>
        <summary>Gets or sets the element at the specified index.</summary>
        <value>The element at the specified index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property provides the ability to access a specific element in the collection by using the following syntax: `myCollection[index]`.  
  
 Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The &lt;see cref="T:System.Object"&gt; to remove from the &lt;xref:System.Collections.CollectionBase&gt;.</param>
        <summary>Removes the first occurrence of a specific object from the &lt;see cref="T:System.Collections.CollectionBase"&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the <xref:System.Collections.CollectionBase> does not contain the specified object, the <xref:System.Collections.CollectionBase> remains unchanged. No exception is thrown.  
  
 This method performs a linear search; therefore, this method is an O() operation, where  is <xref:System.Collections.CollectionBase.Count%2A>.  
  
 This method determines equality by calling <xref:System.Object.Equals%2A?displayProperty=fullName>.  
  
 In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot. If the collection is indexed, the indexes of the elements that are moved are also updated. This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.  
  
   
  
## Examples  
 The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.  
  
 [!CODE [System.Collections.CollectionBase#1](../CodeSnippet/VS_Snippets_CLR_System/system.Collections.CollectionBase#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>