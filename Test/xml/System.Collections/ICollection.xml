<Type Name="ICollection" FullName="System.Collections.ICollection">
  <TypeSignature Language="C#" Value="public interface ICollection : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICollection implements class System.Collections.IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Defines size, enumerators, and synchronization methods for all nongeneric collections.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The ICollection interface is the base interface for classes in the <xref:System.Collections> namespace.  
  
 The ICollection interface extends <xref:System.Collections.IEnumerable>; <xref:System.Collections.IDictionary> and <xref:System.Collections.IList> are more specialized interfaces that extend ICollection. An <xref:System.Collections.IDictionary> implementation is a collection of key/value pairs, like the <xref:System.Collections.Hashtable> class. An <xref:System.Collections.IList> implementation is a collection of values and its members can be accessed by index, like the <xref:System.Collections.ArrayList> class.  
  
 Some collections that limit access to their elements, such as the <xref:System.Collections.Queue> class and the <xref:System.Collections.Stack> class, directly implement the ICollection interface.  
  
 If neither the <xref:System.Collections.IDictionary> interface nor the <xref:System.Collections.IList> interface meet the requirements of the required collection, derive the new collection class from the ICollection interface instead for more flexibility.  
  
 For the generic version of this interface, see <xref:System.Collections.Generic.ICollection%601?displayProperty=fullName>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional &lt;see cref="T:System.Array"&gt; that is the destination of the elements copied from &lt;xref:System.Collections.ICollection&gt;. The &lt;see cref="T:System.Array"&gt; must have zero-based indexing.</param>
        <param name="index">The zero-based index in  at which copying begins.</param>
        <summary>Copies the elements of the &lt;see cref="T:System.Collections.ICollection"&gt; to an &lt;xref:System.Array&gt;, starting at a particular &lt;xref:System.Array&gt; index.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in the &lt;see cref="T:System.Collections.ICollection"&gt;.</summary>
        <value>The number of elements contained in the &lt;see cref="T:System.Collections.ICollection"&gt;.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the &lt;see cref="T:System.Collections.ICollection"&gt; is synchronized (thread safe).</summary>
        <value>`true` if access to the &lt;see cref="T:System.Collections.ICollection"&gt; is synchronized (thread safe); otherwise, `false`.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection.SyncRoot%2A> returns an object, which can be used to synchronize access to the <xref:System.Collections.ICollection>.  
  
 Most collection classes in the <xref:System.Collections?displayProperty=fullName> namespace also implement a Synchronized method, which provides a synchronized wrapper around the underlying collection.  
  
 Enumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.  
  
 The following code example shows how to lock the collection using the <xref:System.Collections.ICollection.SyncRoot%2A> property during the entire enumeration.  
  
 [!CODE [System.Collections.ICollection#1](../CodeSnippet/VS_Snippets_CLR_System/system.collections.icollection#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the &lt;see cref="T:System.Collections.ICollection"&gt;.</summary>
        <value>An object that can be used to synchronize access to the &lt;see cref="T:System.Collections.ICollection"&gt;.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For collections whose underlying store is not publicly available, the expected implementation is to return the current instance. Note that the pointer to the current instance might not be sufficient for collections that wrap other collections; those should return the underlying collection's `SyncRoot` property.  
  
 Most collection classes in the <xref:System.Collections?displayProperty=fullName> namespace also implement a `Synchronized` method, which provides a synchronized wrapper around the underlying collection. However, derived classes can provide their own synchronized version of the collection using the SyncRoot property. The synchronizing code must perform operations on the SyncRoot property of the collection, not directly on the collection. This ensures proper operation of collections that are derived from other objects. Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection instance.  
  
 In the absence of a `Synchronized` method on a collection, the expected usage for SyncRoot looks as follows:  
  
 [!CODE [System.Collections.ICollection#2](../CodeSnippet/VS_Snippets_CLR_System/system.collections.icollection#2)]  
  
 Enumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.  
  
 The following code example shows how to lock the collection using the SyncRoot property during the entire enumeration.  
  
 [!CODE [System.Collections.ICollection#1](../CodeSnippet/VS_Snippets_CLR_System/system.collections.icollection#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>