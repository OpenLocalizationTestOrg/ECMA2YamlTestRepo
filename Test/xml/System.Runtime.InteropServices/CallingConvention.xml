<Type Name="CallingConvention" FullName="System.Runtime.InteropServices.CallingConvention">
  <TypeSignature Language="C#" Value="public enum CallingConvention" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed CallingConvention extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Specifies the calling convention required to call methods implemented in unmanaged code.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Always use the CallingConvention enumeration rather than the <xref:System.Runtime.InteropServices.CALLCONV> enumeration to specify a calling convention in managed code. The latter exists only for the sake of COM definitions. The CallingConvention enumeration is used by <xref:System.Runtime.InteropServices.DllImportAttribute> and several classes in <xref:System.Reflection.Emit> to dynamically emit platform invoke signatures.  
  
   
  
## Examples  
 The following example demonstrates how to apply the `Cdecl` calling convention, which you must use because the stack is cleaned up by the caller.  
  
 [!CODE [Interop CallingConvention#1](../CodeSnippet/VS_Snippets_CLR/Interop CallingConvention#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Cdecl">
      <MemberSignature Language="C#" Value="Cdecl" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.InteropServices.CallingConvention Cdecl = int32(2)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The caller cleans the stack. This enables calling functions with `varargs`, which makes it appropriate to use for methods that accept a variable number of parameters, such as `Printf`.</summary>
      </Docs>
    </Member>
    <Member MemberName="FastCall">
      <MemberSignature Language="C#" Value="FastCall" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.InteropServices.CallingConvention FastCall = int32(5)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This calling convention is not supported.</summary>
      </Docs>
    </Member>
    <Member MemberName="StdCall">
      <MemberSignature Language="C#" Value="StdCall" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.InteropServices.CallingConvention StdCall = int32(3)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The callee cleans the stack. This is the default convention for calling unmanaged functions with platform invoke.</summary>
      </Docs>
    </Member>
    <Member MemberName="ThisCall">
      <MemberSignature Language="C#" Value="ThisCall" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.InteropServices.CallingConvention ThisCall = int32(4)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The first parameter is the `this` pointer and is stored in register ECX. Other parameters are pushed on the stack. This calling convention is used to call methods on classes exported from an unmanaged DLL.</summary>
      </Docs>
    </Member>
    <Member MemberName="Winapi">
      <MemberSignature Language="C#" Value="Winapi" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.InteropServices.CallingConvention Winapi = int32(1)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This member is not actually a calling convention, but instead uses the default platform calling convention. For example, on Windows the default is F:System.Runtime.InteropServices.CallingConvention.StdCall?qualifyHint=False&amp;autoUpgrade=True and on Windows CE.NET it is F:System.Runtime.InteropServices.CallingConvention.Cdecl?qualifyHint=False&amp;autoUpgrade=True.</summary>
      </Docs>
    </Member>
  </Members>
</Type>