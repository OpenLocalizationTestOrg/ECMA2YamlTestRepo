<Type Name="FormatterServices" FullName="System.Runtime.Serialization.FormatterServices">
  <TypeSignature Language="C#" Value="public static class FormatterServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed FormatterServices extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides static methods to aid with the implementation of a &lt;see cref="T:System.Runtime.Serialization.Formatter"&gt; for serialization. This class cannot be inherited.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckTypeSecurity">
      <MemberSignature Language="C#" Value="public static void CheckTypeSecurity (Type t, System.Runtime.Serialization.Formatters.TypeFilterLevel securityLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckTypeSecurity(class System.Type t, valuetype System.Runtime.Serialization.Formatters.TypeFilterLevel securityLevel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="securityLevel" Type="System.Runtime.Serialization.Formatters.TypeFilterLevel" />
      </Parameters>
      <Docs>
        <param name="t">The &lt;see cref="T:System.Type"&gt; to check for the ability to deserialize.</param>
        <param name="securityLevel">The &lt;see cref="T:System.Runtime.Serialization.Formatters.TypeFilterLevel"&gt; property value.</param>
        <summary>Determines whether the specified &lt;see cref="T:System.Type"&gt; can be deserialized with the &lt;xref:System.Runtime.Serialization.Formatters.TypeFilterLevel&gt; property set to `Low`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to determine whether a specified type can be deserialized when the <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel> property is set to `Low`.  
  
 .NET Framework remoting provides two levels of automatic deserialization, <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel> and <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel>. <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel> helps protect against deserialization attacks by deserializing only the types associated with the most basic remoting functionality. The <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel> deserialization level supports automatic deserialization of all types that remoting supports in all situations. For more information about the.NET Framework remoting types that <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel> and <xref:System.Runtime.Serialization.Formatters.TypeFilterLevel> support, see [&#91;\<topic://cpconAutomaticDeserializationInNETRemoting>&#93;](http://msdn.microsoft.com/en-us/313a0e88-5b2b-4a17-8391-0ddf9f7a787b).  
  
   
  
## Examples  
 This example shows how to use the <xref:System.Runtime.Serialization.FormatterServices> class to serialize or deserialize an object where the base class does not implement <xref:System.Runtime.Serialization.ISerializable> but the derived class does.  
  
 [!CODE [FormatterServices#1](../CodeSnippet/VS_Snippets_Remoting/FormatterServices#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static object[] GetObjectData (object obj, System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectData(object obj, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]" />
      </Parameters>
      <Docs>
        <param name="obj">The object to write to the formatter.</param>
        <param name="members">The members to extract from the object.</param>
        <summary>Extracts the data from the specified object and returns it as an array of objects.</summary>
        <returns>An array of &lt;see cref="T:System.Object"&gt; that contains data stored in  and associated with .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For each supplied member of the  array the GetObjectData method extracts the value associated with the  object, and returns it. The length of the returned array is the same as the length of the  array.  
  
   
  
## Examples  
 The following example creates an instance of a Book class and sets field values on the instance. The code then gets the type information using the <xref:System.Runtime.Serialization.FormatterServices.GetSerializableMembers%2A> method. The code copies the instance data into an object array using the GetObjectData method. A new uninitialized instance of the class is created using the <xref:System.Runtime.Serialization.FormatterServices.GetSafeUninitializedObject%2A> method. Finally, the data from the first instance is copied into the second instance using the <xref:System.Runtime.Serialization.FormatterServices.PopulateObjectMembers%2A> method.  
  
 [!CODE [FormatterServices_PopulateObjects#1](../CodeSnippet/VS_Snippets_Remoting/FormatterServices_PopulateObjects#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSafeUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetSafeUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetSafeUninitializedObject(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The type of object to create.</param>
        <summary>Creates a new instance of the specified object type.</summary>
        <returns>A zeroed object of the specified type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Because the new instance of the object is initialized to zero and no constructors are run, the object might not represent a state that is regarded as valid by that object. GetSafeUninitializedObject should only be used for deserialization when the user intends to immediately populate all fields. It does not create an uninitialized string, since creating an empty instance of an immutable type serves no purpose.  
  
 GetSafeUninitializedObject converts all class level [Link Demands](../Topic/Link%20Demands.md) to [Demands](http://msdn.microsoft.com/en-us/e5283e28-2366-4519-b27d-ef5c1ddc1f48) to ensure that all direct and indirect callers have the permissions that the demand specifies. Use GetSafeUninitializedObject to increase the level of security when deserializing from a partially trusted source. For better performance in full trust scenarios, use <xref:System.Runtime.Serialization.FormatterServices.GetUninitializedObject%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializableMembers">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo[] GetSerializableMembers (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo[] GetSerializableMembers(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The type being serialized.</param>
        <summary>Gets all the serializable members for a class of the specified &lt;see cref="T:System.Type"&gt;.</summary>
        <returns>An array of type &lt;see cref="T:System.Reflection.MemberInfo"&gt; of the non-transient, non-static members.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generally, the serializable members of a class are the non-transient, non-static members such as fields and properties. To be included, properties must have both a getter and a setter. A class that implements the <xref:System.Runtime.Serialization.ISerializable> interface or has a serialization surrogate does not have to serialize all these members, or can serialize additional members.  
  
   
  
## Examples  
 The following code example demonstrates implementing the GetSerializableMembers method. This code example is part of a larger example provided for the <xref:System.Runtime.Serialization.FormatterServices> class.  
  
 [!CODE [FormatterServices#2](../CodeSnippet/VS_Snippets_Remoting/FormatterServices#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializableMembers">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo[] GetSerializableMembers (Type type, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo[] GetSerializableMembers(class System.Type type, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="type">The type being serialized or cloned.</param>
        <param name="context">The context where the serialization occurs.</param>
        <summary>Gets all the serializable members for a class of the specified &lt;see cref="T:System.Type"&gt; and in the provided &lt;xref:System.Runtime.Serialization.StreamingContext&gt;.</summary>
        <returns>An array of type &lt;see cref="T:System.Reflection.MemberInfo"&gt; of the non-transient, non-static members.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generally, the serializable members of a class are the non-transient, non-static members such as fields and properties. To be included, properties must have both a getter and a setter. A class that implements <xref:System.Runtime.Serialization.ISerializable> or has a serialization surrogate does not have to serialize all these members, or can serialize additional members.  
  
 Currently, you do not need to do anything different unless  has the <xref:System.Runtime.Serialization.StreamingContextStates> value <xref:System.Runtime.Serialization.StreamingContextStates> set.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSurrogateForCyclicalReference">
      <MemberSignature Language="C#" Value="public static System.Runtime.Serialization.ISerializationSurrogate GetSurrogateForCyclicalReference (System.Runtime.Serialization.ISerializationSurrogate innerSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Serialization.ISerializationSurrogate GetSurrogateForCyclicalReference(class System.Runtime.Serialization.ISerializationSurrogate innerSurrogate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.ISerializationSurrogate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="innerSurrogate" Type="System.Runtime.Serialization.ISerializationSurrogate" />
      </Parameters>
      <Docs>
        <param name="innerSurrogate">The specified surrogate.</param>
        <summary>Returns a serialization surrogate for the specified &lt;see cref="T:System.Runtime.Serialization.ISerializationSurrogate"&gt;.</summary>
        <returns>An &lt;see cref="T:System.Runtime.Serialization.ISerializationSurrogate"&gt; for the specified .</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromAssembly">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromAssembly (System.Reflection.Assembly assem, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromAssembly(class System.Reflection.Assembly assem, string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assem" Type="System.Reflection.Assembly" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assem">The assembly where you want to look up the object.</param>
        <param name="name">The name of the object.</param>
        <summary>Looks up the &lt;see cref="T:System.Type"&gt; of the specified object in the provided &lt;xref:System.Reflection.Assembly&gt;.</summary>
        <returns>The &lt;see cref="T:System.Type"&gt; of the named object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The type of object to create.</param>
        <summary>Creates a new instance of the specified object type.</summary>
        <returns>A zeroed object of the specified type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Because the new instance of the object is initialized to zero and no constructors are run, the object might not represent a state that is regarded as valid by that object. The current method should only be used for deserialization when the user intends to immediately populate all fields. It does not create an uninitialized string, since creating an empty instance of an immutable type serves no purpose.  
  
> [!NOTE]
>  You cannot use the GetUninitializedObject method to create instances of types that derive from the <xref:System.ContextBoundObject> class.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateObjectMembers">
      <MemberSignature Language="C#" Value="public static object PopulateObjectMembers (object obj, System.Reflection.MemberInfo[] members, object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PopulateObjectMembers(object obj, class System.Reflection.MemberInfo[] members, object[] data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]" />
        <Parameter Name="data" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">The object to populate.</param>
        <param name="members">An array of &lt;see cref="T:System.Reflection.MemberInfo"&gt; that describes which fields and properties to populate.</param>
        <param name="data">An array of &lt;see cref="T:System.Object"&gt; that specifies the values for each field and property to populate.</param>
        <summary>Populates the specified object with values for each field drawn from the data array of objects.</summary>
        <returns>The newly populated object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If an element in  is `null`, PopulateObjectMembers does not write anything to that field.  
  
   
  
## Examples  
 The following example creates an instance of a Book class and sets field values on the instance. The code then gets the type information using the <xref:System.Runtime.Serialization.FormatterServices.GetSerializableMembers%2A> method. The code copies the instance data into an object array using the <xref:System.Runtime.Serialization.FormatterServices.GetObjectData%2A> method. A new uninitialized instance of the class is created using the <xref:System.Runtime.Serialization.FormatterServices.GetSafeUninitializedObject%2A> method. Finally, the data from the first instance is copied into the second instance using the PopulateObjectMembers method.  
  
 [!CODE [FormatterServices_PopulateObjects#1](../CodeSnippet/VS_Snippets_Remoting/FormatterServices_PopulateObjects#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>