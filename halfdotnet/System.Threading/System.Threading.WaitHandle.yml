### YamlMime:ManagedReference
items:
- uid: System.Threading.WaitHandle
  id: WaitHandle
  children:
  - System.Threading.WaitHandle.#ctor
  - System.Threading.WaitHandle.Close
  - System.Threading.WaitHandle.Dispose
  - System.Threading.WaitHandle.Dispose(System.Boolean)
  - System.Threading.WaitHandle.Handle
  - System.Threading.WaitHandle.InvalidHandle
  - System.Threading.WaitHandle.SafeWaitHandle
  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)
  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)
  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  - System.Threading.WaitHandle.WaitOne
  - System.Threading.WaitHandle.WaitOne(System.Int32)
  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  - System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)
  - System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)
  - System.Threading.WaitHandle.WaitTimeout
  langs:
  - csharp
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
  type: Class
  summary: Encapsulates operating system–specific objects that wait for exclusive access to shared resources.
  remarks: "The WaitHandle class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](../Topic/Overview%20of%20Synchronization%20Primitives.md).  \n  \n The WaitHandle class itself is abstract. Classes derived from WaitHandle define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited WaitHandle methods to block while waiting for access to shared resources. The classes derived from WaitHandle include:  \n  \n-   The <xref:System.Threading.Mutex> class. See [Mutexes](../Topic/Mutexes.md).  \n  \n-   The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>. See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../Topic/EventWaitHandle,%20AutoResetEvent,%20CountdownEvent,%20ManualResetEvent.md).  \n  \n-   The <xref:System.Threading.Semaphore> class. See [Semaphore and SemaphoreSlim](../Topic/Semaphore%20and%20SemaphoreSlim.md).  \n  \n Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from WaitHandle.  \n  \n The derived classes of WaitHandle differ in their thread affinity. Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.  \n  \n Because the WaitHandle class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.  \n  \n In addition to its derived classes, the WaitHandle class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:  \n  \n-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.  \n  \n-   <xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.  \n  \n-   <xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .  \n  \n The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n WaitHandle implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](../Topic/Dispose%20Pattern.md). When you derive from WaitHandle, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources."
  example:
  - "The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the WaitHandle class.  \n  \n [!CODE [WaitHandle#1](../CodeSnippet/VS_Snippets_CLR/WaitHandle#1)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public abstract class WaitHandle : MarshalByRefObject, IDisposable
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.#ctor
  id: '#ctor'
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitHandle()
  nameWithType: WaitHandle.WaitHandle()
  fullName: System.Threading.WaitHandle.WaitHandle()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Initializes a new instance of the <see cref="T:System.Threading.WaitHandle"> class.
  remarks: To be added.
  syntax:
    content: protected WaitHandle ();
    parameters: []
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.Close
  id: Close
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: Close()
  nameWithType: WaitHandle.Close()
  fullName: System.Threading.WaitHandle.Close()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Releases all resources held by the current <see cref="T:System.Threading.WaitHandle">.
  remarks: "This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method for the <xref:System.Threading.WaitHandle> class and its derived classes. It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method. Call this method to release all resources held by an instance of `WaitHandle` or a derived class.  \n  \n Once this method is called, references to the current instance cause undefined behavior.  \n  \n> [!NOTE]\n>  Always call Close or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed."
  syntax:
    content: public virtual void Close ();
    parameters: []
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.Dispose
  id: Dispose
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: Dispose()
  nameWithType: WaitHandle.Dispose()
  fullName: System.Threading.WaitHandle.Dispose()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle"> class.
  remarks: "This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.  \n  \n> [!NOTE]\n>  Always call <xref:System.Threading.WaitHandle.Close%2A> or Dispose before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Threading.WaitHandle.Dispose*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: WaitHandle.Dispose(Boolean)
  fullName: System.Threading.WaitHandle.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle">, and optionally releases the managed resources.
  remarks: This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the  parameter set to `true`.  When the  parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.
  syntax:
    content: protected virtual void Dispose (bool explicitDisposing);
    parameters:
    - id: explicitDisposing
      type: System.Boolean
      description: '`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources.'
  overload: System.Threading.WaitHandle.Dispose*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.Handle
  id: Handle
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: Handle
  nameWithType: WaitHandle.Handle
  fullName: System.Threading.WaitHandle.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Gets or sets the native operating system handle.
  remarks: "Assigning a new value to the Handle property does not close the previous handle. This can result in a leaked handle.  \n  \n Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead. Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle."
  syntax:
    content: public virtual IntPtr Handle { get; set; }
    return:
      type: System.IntPtr
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.InvalidHandle
  id: InvalidHandle
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: InvalidHandle
  nameWithType: WaitHandle.InvalidHandle
  fullName: System.Threading.WaitHandle.InvalidHandle
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Represents an invalid native operating system handle. This field is read-only.
  remarks: Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.
  syntax:
    content: protected static readonly IntPtr InvalidHandle;
    return:
      type: System.IntPtr
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.SafeWaitHandle
  id: SafeWaitHandle
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: SafeWaitHandle
  nameWithType: WaitHandle.SafeWaitHandle
  fullName: System.Threading.WaitHandle.SafeWaitHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Gets or sets the native operating system handle.
  remarks: "When you assign a new value to the SafeWaitHandle property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected. Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.  \n  \n <xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](../Topic/Dispose%20Pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the SafeWaitHandle property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeWaitHandle
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)
  id: SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: SignalAndWait(WaitHandle,WaitHandle)
  nameWithType: WaitHandle.SignalAndWait(WaitHandle,WaitHandle)
  fullName: System.Threading.WaitHandle.SignalAndWait(WaitHandle,WaitHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Signals one <see cref="T:System.Threading.WaitHandle"> and waits on another.
  remarks: This operation is not guaranteed to be atomic. After the current thread signals  but before it waits on , a thread that is running on another processor might signal  or wait on it.
  example:
  - "The following code example uses the SignalAndWait method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  \n  \n The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode?displayProperty=fullName> flag, and then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode?displayProperty=fullName> flag.  \n  \n [!CODE [System.Threading.WaitHandle.SignalAndWait#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait#1)]"
  syntax:
    content: public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);
    parameters:
    - id: toSignal
      type: System.Threading.WaitHandle
      description: The <see cref="T:System.Threading.WaitHandle"> to signal.
    - id: toWaitOn
      type: System.Threading.WaitHandle
      description: The <see cref="T:System.Threading.WaitHandle"> to wait on.
    return:
      type: System.Boolean
      description: '`true` if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.'
  overload: System.Threading.WaitHandle.SignalAndWait*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)
  id: SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)
  nameWithType: WaitHandle.SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)
  fullName: System.Threading.WaitHandle.SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Signals one <see cref="T:System.Threading.WaitHandle"> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.
  remarks: "This operation is not guaranteed to be atomic. After the current thread signals  but before it waits on , a thread that is running on another processor might signal  or wait on it.  \n  \n If  is zero, the method does not block. It tests the state of the  and returns immediately.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the SignalAndWait method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the SignalAndWait method. The thread returns to the original nondefault context after the call to the SignalAndWait method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the SignalAndWait method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the SignalAndWait method returns, the thread that made the call must wait to reenter the synchronization domain."
  syntax:
    content: public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    parameters:
    - id: toSignal
      type: System.Threading.WaitHandle
      description: The <see cref="T:System.Threading.WaitHandle"> to signal.
    - id: toWaitOn
      type: System.Threading.WaitHandle
      description: The <see cref="T:System.Threading.WaitHandle"> to wait on.
    - id: millisecondsTimeout
      type: System.Int32
      description: An integer that represents the interval to wait. If the value is <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>, that is, -1, the wait is infinite.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Boolean
      description: '`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out.'
  overload: System.Threading.WaitHandle.SignalAndWait*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)
  id: SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)
  nameWithType: WaitHandle.SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Signals one <see cref="T:System.Threading.WaitHandle"> and waits on another, specifying the time-out interval as a <xref:System.TimeSpan> and specifying whether to exit the synchronization domain for the context before entering the wait.
  remarks: "This operation is not guaranteed to be atomic. After the current thread signals  but before it waits on , a thread that is running on another processor might signal  or wait on it.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n If  is zero, the method does not block. It tests the state of the  and returns immediately.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the SignalAndWait method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the SignalAndWait method. The thread returns to the original nondefault context after the call to the SignalAndWait method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the SignalAndWait method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the SignalAndWait method returns, the thread that made the call must wait to reenter the synchronization domain."
  syntax:
    content: public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    parameters:
    - id: toSignal
      type: System.Threading.WaitHandle
      description: The <see cref="T:System.Threading.WaitHandle"> to signal.
    - id: toWaitOn
      type: System.Threading.WaitHandle
      description: The <see cref="T:System.Threading.WaitHandle"> to wait on.
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the interval to wait. If the value is -1, the wait is infinite.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Boolean
      description: '`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out.'
  overload: System.Threading.WaitHandle.SignalAndWait*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  id: WaitAll(System.Threading.WaitHandle[])
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAll(WaitHandle[])
  nameWithType: WaitHandle.WaitAll(WaitHandle[])
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for all the elements in the specified array to receive a signal.
  remarks: "<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n Calling this method overload is equivalent to calling the [WaitAll(WaitHandle\\[\\], Int32, Boolean)](assetId:///M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)?qualifyHint=False&autoUpgrade=False) method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for and `true` for ."
  example:
  - "The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  \n  \n [!CODE [System.Threading.WaitHandle.WaitAll1#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1#1)]"
  syntax:
    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.
    return:
      type: System.Boolean
      description: '`true` when every element in  has received a signal; otherwise the method never returns.'
  overload: System.Threading.WaitHandle.WaitAll*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)
  id: WaitAll(System.Threading.WaitHandle[],System.Int32)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAll(WaitHandle[],Int32)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],Int32)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32"> value to specify the time interval.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n Calling this method overload is the same as calling the [WaitAll(WaitHandle\\[\\], Int32, Boolean)](assetId:///M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)?qualifyHint=False&autoUpgrade=False) overload and specifying `false` for ."
  syntax:
    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> (-1) to wait indefinitely.
    return:
      type: System.Boolean
      description: '`true` when every element in  has received a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitAll*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  id: WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAll(WaitHandle[],TimeSpan)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],TimeSpan)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan"> value to specify the time interval.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n Calling this method overload is the same as calling the [WaitAll(WaitHandle\\[\\], TimeSpan, Boolean)](assetId:///M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)?qualifyHint=False&autoUpgrade=False) overload and specifying `false` for ."
  syntax:
    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"> that represents -1 milliseconds, to wait indefinitely.
    return:
      type: System.Boolean
      description: '`true` when every element in  has received a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitAll*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  id: WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAll(WaitHandle[],Int32,Boolean)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],Int32,Boolean)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32"> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the WaitAll method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAll method. The thread returns to the original nondefault context after the call to the WaitAll method completes.  \n  \n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAll method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAll method returns, the thread that made the call must wait to reenter the synchronization domain."
  example:
  - "The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  \n  \n [!CODE [System.Threading.WaitHandle.WaitAll2#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2#1)]"
  syntax:
    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> (-1) to wait indefinitely.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Boolean
      description: '`true` when every element in  has received a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitAll*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  id: WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAll(WaitHandle[],TimeSpan,Boolean)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan"> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the WaitAll method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAll method. It returns to the original nondefault context after the call to the WaitAll method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAll method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAll method returns, the thread that made the call must wait to reenter the synchronization domain."
  example:
  - "The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  \n  \n [!CODE [System.Threading.WaitHandle.WaitAll3#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3#1)]"
  syntax:
    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"> that represents -1 milliseconds, to wait indefinitely.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Boolean
      description: '`true` when every element in  has received a signal; otherwise `false`.'
  overload: System.Threading.WaitHandle.WaitAll*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  id: WaitAny(System.Threading.WaitHandle[])
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAny(WaitHandle[])
  nameWithType: WaitHandle.WaitAny(WaitHandle[])
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for any of the elements in the specified array to receive a signal.
  remarks: "<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If  contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n> [!NOTE]\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \n  \n This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n Calling this method overload is equivalent to calling the [WaitAny(WaitHandle\\[\\], Int32, Boolean)](assetId:///M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)?qualifyHint=False&autoUpgrade=False) method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for and `true` for ."
  example:
  - "The following code example demonstrates calling the WaitAnymethod.  \n  \n [!CODE [WaitHandle#1](../CodeSnippet/VS_Snippets_CLR/WaitHandle#1)]"
  syntax:
    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait.
    return:
      type: System.Int32
      description: The array index of the object that satisfied the wait.
  overload: System.Threading.WaitHandle.WaitAny*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)
  id: WaitAny(System.Threading.WaitHandle[],System.Int32)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAny(WaitHandle[],Int32)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],Int32)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If  contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n Calling this method overload is the same as calling the [WaitAny(WaitHandle\\[\\], Int32, Boolean)](assetId:///M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)?qualifyHint=False&autoUpgrade=False) overload and specifying `false` for ."
  syntax:
    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait.
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> (-1) to wait indefinitely.
    return:
      type: System.Int32
      description: The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout"> if no object satisfied the wait and a time interval equivalent to  has passed.
  overload: System.Threading.WaitHandle.WaitAny*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  id: WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAny(WaitHandle[],TimeSpan)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],TimeSpan)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan"> to specify the time interval.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If  contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n Calling this method overload is the same as calling the [WaitAny(WaitHandle\\[\\], TimeSpan, Boolean)](assetId:///M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)?qualifyHint=False&autoUpgrade=False) overload and specifying `false` for ."
  syntax:
    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait.
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"> that represents -1 milliseconds to wait indefinitely.
    return:
      type: System.Int32
      description: The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout"> if no object satisfied the wait and a time interval equivalent to  has passed.
  overload: System.Threading.WaitHandle.WaitAny*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  id: WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAny(WaitHandle[],Int32,Boolean)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],Int32,Boolean)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If  contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n> [!NOTE]\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the WaitAny method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAny method. The thread returns to the original nondefault context after the call to the WaitAny method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAny method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAny method returns, the thread that made the call must wait to reenter the synchronization domain."
  example:
  - "The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  \n  \n [!CODE [System.Threading.WaitHandle.WaitAny2#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2#1)]"
  syntax:
    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait.
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> (-1) to wait indefinitely.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Int32
      description: The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout"> if no object satisfied the wait and a time interval equivalent to  has passed.
  overload: System.Threading.WaitHandle.WaitAny*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  id: WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitAny(WaitHandle[],TimeSpan,Boolean)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan"> to specify the time interval and specifying whether to exit the synchronization domain before the wait.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If  contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n> [!NOTE]\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the WaitAny method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAny method. The thread returns to the original nondefault context after the call to the WaitAny method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAny method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAny method returns, the thread that made the call must wait to reenter the synchronization domain."
  example:
  - "The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  \n  \n [!CODE [System.Threading.WaitHandle.WaitAny3#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3#1)]"
  syntax:
    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: A `WaitHandle` array containing the objects for which the current instance will wait.
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"> that represents -1 milliseconds to wait indefinitely.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Int32
      description: The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout"> if no object satisfied the wait and a time interval equivalent to  has passed.
  overload: System.Threading.WaitHandle.WaitAny*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitOne
  id: WaitOne
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitOne()
  nameWithType: WaitHandle.WaitOne()
  fullName: System.Threading.WaitHandle.WaitOne()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle"> receives a signal.
  remarks: "<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> for the first parameter and `false` for the second parameter.  \n  \n Override this method to customize the behavior of derived classes."
  example:
  - "The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  \n  \n [!CODE [System.Threading.WaitHandle.WaitOne1#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1#1)]"
  syntax:
    content: public virtual bool WaitOne ();
    parameters: []
    return:
      type: System.Boolean
      description: '`true` if the current instance receives a signal. If the current instance is never signaled, <xref:System.Threading.WaitHandle.WaitOne%2A> never returns.'
  overload: System.Threading.WaitHandle.WaitOne*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitOne(System.Int32)
  id: WaitOne(System.Int32)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitOne(Int32)
  nameWithType: WaitHandle.WaitOne(Int32)
  fullName: System.Threading.WaitHandle.WaitOne(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle"> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for ."
  example:
  - "The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  \n  \n [!CODE [System.Threading.WaitHandle.WaitOne2#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2#1)]"
  syntax:
    content: public virtual bool WaitOne (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> (-1) to wait indefinitely.
    return:
      type: System.Boolean
      description: '`true` if the current instance receives a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitOne*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  id: WaitOne(System.TimeSpan)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitOne(TimeSpan)
  nameWithType: WaitHandle.WaitOne(TimeSpan)
  fullName: System.Threading.WaitHandle.WaitOne(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan"> to specify the time interval.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for ."
  syntax:
    content: public virtual bool WaitOne (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"> that represents -1 milliseconds to wait indefinitely.
    return:
      type: System.Boolean
      description: '`true` if the current instance receives a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitOne*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)
  id: WaitOne(System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitOne(Int32,Boolean)
  nameWithType: WaitHandle.WaitOne(Int32,Boolean)
  fullName: System.Threading.WaitHandle.WaitOne(Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle"> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the WaitOne method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitOne method. The thread returns to the original nondefault context after the call to the WaitOne method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitOne method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitOne method returns, the thread that made the call must wait to reenter the synchronization domain."
  example:
  - "The following example shows how the WaitOne method overload behaves when it is called within a synchronization domain. First, a thread waits with  set to `false` and blocks until the wait timeout expires. A second thread executes after the first thread terminates and waits with  set to `true`. The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.  \n  \n [!CODE [System.Threading.WaitHandle.WaitOne4#1](../CodeSnippet/VS_Snippets_CLR_System/system.threading.waithandle.waitone4#1)]"
  syntax:
    content: public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> (-1) to wait indefinitely.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Boolean
      description: '`true` if the current instance receives a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitOne*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)
  id: WaitOne(System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitOne(TimeSpan,Boolean)
  nameWithType: WaitHandle.WaitOne(TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.WaitOne(TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan"> to specify the time interval and specifying whether to exit the synchronization domain before the wait.
  remarks: "If  is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n The maximum value for  is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n## Notes on Exiting the Context  \n The  parameter has no effect unless the WaitOne method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for  causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitOne method. The thread returns to the original nondefault context after the call to the WaitOne method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitOne method and specifies `true` for , the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitOne method returns, the thread that made the call must wait to reenter the synchronization domain."
  example:
  - "The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  \n  \n [!CODE [System.Threading.WaitHandle.WaitOne3#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3#1)]"
  syntax:
    content: public virtual bool WaitOne (TimeSpan timeout, bool exitContext);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: A <see cref="T:System.TimeSpan"> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"> that represents -1 milliseconds to wait indefinitely.
    - id: exitContext
      type: System.Boolean
      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'
    return:
      type: System.Boolean
      description: '`true` if the current instance receives a signal; otherwise, `false`.'
  overload: System.Threading.WaitHandle.WaitOne*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Threading.WaitHandle.WaitTimeout
  id: WaitTimeout
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  name: WaitTimeout
  nameWithType: WaitHandle.WaitTimeout
  fullName: System.Threading.WaitHandle.WaitTimeout
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Indicates that a <xref:System.Threading.WaitHandle.WaitAny%2A> operation timed out before any of the wait handles were signaled. This field is constant.
  remarks: This field is one of the possible return values of `WaitAny`.
  example:
  - "The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  \n  \n [!CODE [System.Threading.WaitHandle.WaitAny2#1](../CodeSnippet/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2#1)]"
  syntax:
    content: public const int WaitTimeout = 258;
    return:
      type: System.Int32
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.Threading.WaitHandle.#ctor
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitHandle()
  nameWithType: WaitHandle.WaitHandle()
  fullName: System.Threading.WaitHandle.WaitHandle()
- uid: System.Threading.WaitHandle.Close
  parent: System.Threading.WaitHandle
  isExternal: false
  name: Close()
  nameWithType: WaitHandle.Close()
  fullName: System.Threading.WaitHandle.Close()
- uid: System.Threading.WaitHandle.Dispose
  parent: System.Threading.WaitHandle
  isExternal: false
  name: Dispose()
  nameWithType: WaitHandle.Dispose()
  fullName: System.Threading.WaitHandle.Dispose()
- uid: System.Threading.WaitHandle.Dispose(System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: WaitHandle.Dispose(Boolean)
  fullName: System.Threading.WaitHandle.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.Handle
  parent: System.Threading.WaitHandle
  isExternal: false
  name: Handle
  nameWithType: WaitHandle.Handle
  fullName: System.Threading.WaitHandle.Handle
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.WaitHandle.InvalidHandle
  parent: System.Threading.WaitHandle
  isExternal: false
  name: InvalidHandle
  nameWithType: WaitHandle.InvalidHandle
  fullName: System.Threading.WaitHandle.InvalidHandle
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.WaitHandle.SafeWaitHandle
  parent: System.Threading.WaitHandle
  isExternal: false
  name: SafeWaitHandle
  nameWithType: WaitHandle.SafeWaitHandle
  fullName: System.Threading.WaitHandle.SafeWaitHandle
- uid: Microsoft.Win32.SafeHandles.SafeWaitHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeWaitHandle
  nameWithType: SafeWaitHandle
  fullName: Microsoft.Win32.SafeHandles.SafeWaitHandle
- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: SignalAndWait(WaitHandle,WaitHandle)
  nameWithType: WaitHandle.SignalAndWait(WaitHandle,WaitHandle)
  fullName: System.Threading.WaitHandle.SignalAndWait(WaitHandle,WaitHandle)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)
  nameWithType: WaitHandle.SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)
  fullName: System.Threading.WaitHandle.SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)
  nameWithType: WaitHandle.SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAll(WaitHandle[])
  nameWithType: WaitHandle.WaitAll(WaitHandle[])
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[])
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAll(WaitHandle[],Int32)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],Int32)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],Int32)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAll(WaitHandle[],TimeSpan)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],TimeSpan)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],TimeSpan)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAll(WaitHandle[],Int32,Boolean)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],Int32,Boolean)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],Int32,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAll(WaitHandle[],TimeSpan,Boolean)
  nameWithType: WaitHandle.WaitAll(WaitHandle[],TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.WaitAll(WaitHandle[],TimeSpan,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAny(WaitHandle[])
  nameWithType: WaitHandle.WaitAny(WaitHandle[])
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[])
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAny(WaitHandle[],Int32)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],Int32)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],Int32)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAny(WaitHandle[],TimeSpan)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],TimeSpan)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],TimeSpan)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAny(WaitHandle[],Int32,Boolean)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],Int32,Boolean)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],Int32,Boolean)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitAny(WaitHandle[],TimeSpan,Boolean)
  nameWithType: WaitHandle.WaitAny(WaitHandle[],TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.WaitAny(WaitHandle[],TimeSpan,Boolean)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle[]
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitOne
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitOne()
  nameWithType: WaitHandle.WaitOne()
  fullName: System.Threading.WaitHandle.WaitOne()
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitOne(System.Int32)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitOne(Int32)
  nameWithType: WaitHandle.WaitOne(Int32)
  fullName: System.Threading.WaitHandle.WaitOne(Int32)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitOne(TimeSpan)
  nameWithType: WaitHandle.WaitOne(TimeSpan)
  fullName: System.Threading.WaitHandle.WaitOne(TimeSpan)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitOne(Int32,Boolean)
  nameWithType: WaitHandle.WaitOne(Int32,Boolean)
  fullName: System.Threading.WaitHandle.WaitOne(Int32,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitOne(TimeSpan,Boolean)
  nameWithType: WaitHandle.WaitOne(TimeSpan,Boolean)
  fullName: System.Threading.WaitHandle.WaitOne(TimeSpan,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle.WaitTimeout
  parent: System.Threading.WaitHandle
  isExternal: false
  name: WaitTimeout
  nameWithType: WaitHandle.WaitTimeout
  fullName: System.Threading.WaitHandle.WaitTimeout
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle.Dispose*
  parent: System.Threading.WaitHandle
  isExternal: false
  nameWithType: WaitHandle.
- uid: System.Threading.WaitHandle.SignalAndWait*
  parent: System.Threading.WaitHandle
  isExternal: false
  nameWithType: WaitHandle.
- uid: System.Threading.WaitHandle.WaitAll*
  parent: System.Threading.WaitHandle
  isExternal: false
  nameWithType: WaitHandle.
- uid: System.Threading.WaitHandle.WaitAny*
  parent: System.Threading.WaitHandle
  isExternal: false
  nameWithType: WaitHandle.
- uid: System.Threading.WaitHandle.WaitOne*
  parent: System.Threading.WaitHandle
  isExternal: false
  nameWithType: WaitHandle.
