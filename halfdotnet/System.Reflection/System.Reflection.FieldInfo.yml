### YamlMime:ManagedReference
items:
- uid: System.Reflection.FieldInfo
  id: FieldInfo
  children:
  - System.Reflection.FieldInfo.#ctor
  - System.Reflection.FieldInfo.Attributes
  - System.Reflection.FieldInfo.Equals(System.Object)
  - System.Reflection.FieldInfo.FieldHandle
  - System.Reflection.FieldInfo.FieldType
  - System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)
  - System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  - System.Reflection.FieldInfo.GetHashCode
  - System.Reflection.FieldInfo.GetOptionalCustomModifiers
  - System.Reflection.FieldInfo.GetRawConstantValue
  - System.Reflection.FieldInfo.GetRequiredCustomModifiers
  - System.Reflection.FieldInfo.GetValue(System.Object)
  - System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)
  - System.Reflection.FieldInfo.IsAssembly
  - System.Reflection.FieldInfo.IsFamily
  - System.Reflection.FieldInfo.IsFamilyAndAssembly
  - System.Reflection.FieldInfo.IsFamilyOrAssembly
  - System.Reflection.FieldInfo.IsInitOnly
  - System.Reflection.FieldInfo.IsLiteral
  - System.Reflection.FieldInfo.IsNotSerialized
  - System.Reflection.FieldInfo.IsPinvokeImpl
  - System.Reflection.FieldInfo.IsPrivate
  - System.Reflection.FieldInfo.IsPublic
  - System.Reflection.FieldInfo.IsSecurityCritical
  - System.Reflection.FieldInfo.IsSecuritySafeCritical
  - System.Reflection.FieldInfo.IsSecurityTransparent
  - System.Reflection.FieldInfo.IsSpecialName
  - System.Reflection.FieldInfo.IsStatic
  - System.Reflection.FieldInfo.MemberType
  - System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  - System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  - System.Reflection.FieldInfo.SetValue(System.Object,System.Object)
  - System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)
  - System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)
  - System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType
  - System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)
  - System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  langs:
  - csharp
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
  type: Class
  summary: Discovers the attributes of a field and provides access to field metadata.
  remarks: "The field information is obtained from metadata. The FieldInfo class does not have a public constructor. FieldInfo objects are obtained by calling either the <xref:System.Type.GetFields%2A> or <xref:System.Type.GetField%2A> method of a `Type` object.  \n  \n Fields are variables defined in the class. FieldInfo provides access to the metadata for a field within a class and provides dynamic set and get functionality for the field. The class is not loaded into memory until invoke or get is called on the object."
  example:
  - "The following example uses the <xref:System.Type.GetFields%2A?displayProperty=fullName> method to get the field-related information from the FieldInfo class, and then displays field attributes.  \n  \n [!CODE [FieldInfo#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo#1)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._FieldInfo))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public abstract class FieldInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._FieldInfo
  inheritance:
  - System.Object
  - System.Reflection.MemberInfo
  implements:
  - System.Runtime.InteropServices._FieldInfo
  inheritedMembers:
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  - System.Reflection.MemberInfo.CustomAttributes
  - System.Reflection.MemberInfo.DeclaringType
  - System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)
  - System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)
  - System.Reflection.MemberInfo.GetCustomAttributesData
  - System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)
  - System.Reflection.MemberInfo.MetadataToken
  - System.Reflection.MemberInfo.Module
  - System.Reflection.MemberInfo.Name
  - System.Reflection.MemberInfo.op_Equality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)
  - System.Reflection.MemberInfo.op_Inequality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)
  - System.Reflection.MemberInfo.ReflectedType
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetType
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.#ctor
  id: '#ctor'
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: FieldInfo()
  nameWithType: FieldInfo.FieldInfo()
  fullName: System.Reflection.FieldInfo.FieldInfo()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Initializes a new instance of the `FieldInfo` class.
  remarks: To be added.
  syntax:
    content: protected FieldInfo ();
    parameters: []
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.Attributes
  id: Attributes
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: Attributes
  nameWithType: FieldInfo.Attributes
  fullName: System.Reflection.FieldInfo.Attributes
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets the attributes associated with this field.
  remarks: "All members have a set of attributes, which are defined in relation to the specific type of member. `FieldAttributes` informs the user whether this field is the private field, a static field, and so on.  \n  \n To get the `Attributes` property, first get the class `Type`. From the `Type`, get the `FieldInfo`. From the `FieldInfo`, get the `Attributes`."
  example:
  - "The following code example builds three fields and displays their field attributes. A `FieldAttributes` value can contain more than one attribute, such as both `Public` and `Literal`, as shown in the third field.  \n  \n [!CODE [Classic FieldAttributes Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldAttributes Example#1)]"
  syntax:
    content: public abstract System.Reflection.FieldAttributes Attributes { get; }
    return:
      type: System.Reflection.FieldAttributes
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: FieldInfo.Equals(Object)
  fullName: System.Reflection.FieldInfo.Equals(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Returns a value that indicates whether this instance is equal to a specified object.
  remarks: To be added.
  syntax:
    content: public override bool Equals (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: An object to compare with this instance, or `null`.
    return:
      type: System.Boolean
      description: '`true` if  equals the type and value of this instance; otherwise, `false`.'
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.FieldHandle
  id: FieldHandle
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: FieldHandle
  nameWithType: FieldInfo.FieldHandle
  fullName: System.Reflection.FieldInfo.FieldHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a `RuntimeFieldHandle`, which is a handle to the internal metadata representation of a field.
  remarks: The handles are valid only in the appdomain in which they were obtained.
  example:
  - "The following example retrieves MyClass.MyField field information and displays the field associated with the field handle.  \n  \n [!CODE [FieldInfo_FieldHandle#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_FieldHandle#1)]"
  syntax:
    content: public abstract RuntimeFieldHandle FieldHandle { get; }
    return:
      type: System.RuntimeFieldHandle
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.FieldType
  id: FieldType
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: FieldType
  nameWithType: FieldInfo.FieldType
  fullName: System.Reflection.FieldInfo.FieldType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets the type of this field object.
  remarks: "The type is some primitive data type, such as `String`, `Boolean`, or `GUID`.  \n  \n To get the `FieldType` property, first get the class `Type`. From the `Type`, get the `FieldInfo`. From the `FieldInfo`, get the `FieldType` value."
  example:
  - "The following example creates a field, gets its type and <xref:System.Reflection.FieldInfo>, and displays its FieldType.  \n  \n [!CODE [Classic FieldInfo.FieldType Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example#1)]"
  syntax:
    content: public abstract Type FieldType { get; }
    return:
      type: System.Type
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)
  id: GetFieldFromHandle(System.RuntimeFieldHandle)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetFieldFromHandle(RuntimeFieldHandle)
  nameWithType: FieldInfo.GetFieldFromHandle(RuntimeFieldHandle)
  fullName: System.Reflection.FieldInfo.GetFieldFromHandle(RuntimeFieldHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a <see cref="T:System.Reflection.FieldInfo"> for the field represented by the specified handle.
  remarks: Handles are valid only in the application domain in which they were obtained.
  example:
  - "The following code example uses the <xref:System.Type.GetFields%2A?displayProperty=fullName> method to get <xref:System.Reflection.FieldInfo> objects for the fields of a type, gets a <xref:System.RuntimeFieldHandle> structure for each field, and then retrieves the <xref:System.Reflection.FieldInfo> objects from the handles using this overload of the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A> method.  \n  \n [!CODE [FieldInfo_GetFieldFromHandle#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle#1)]"
  syntax:
    content: public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle);
    parameters:
    - id: handle
      type: System.RuntimeFieldHandle
      description: A <see cref="T:System.RuntimeFieldHandle"> structure that contains the handle to the internal metadata representation of a field.
    return:
      type: System.Reflection.FieldInfo
      description: A <see cref="T:System.Reflection.FieldInfo"> object representing the field specified by .
  overload: System.Reflection.FieldInfo.GetFieldFromHandle*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  id: GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetFieldFromHandle(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: FieldInfo.GetFieldFromHandle(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.FieldInfo.GetFieldFromHandle(RuntimeFieldHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a <see cref="T:System.Reflection.FieldInfo"> for the field represented by the specified handle, for the specified generic type.
  remarks: "Handles are valid only in the application domain in which they were obtained.  \n  \n The recommended practice is that  should always be the runtime type handle of the constructed type that  belongs to. That is, if  is a runtime field handle for a field that belongs to `MyType<int>` (`MyType(Of Integer)` in Visual Basic),  is the runtime type handle for `MyType<int>`. Do not use the runtime type handle of the generic type definition, unless the runtime field handle represents a field on the generic type definition.  \n  \n Implementations are compatible in some cases. For example, a single implementation is shared by all types that are constructed from a particular generic type definition by using reference types for the generic type arguments. For example, `MyType<string>`, `MyType<object>`, and `MyType<ArrayList>` all share the same implementation. In this situation, the <xref:System.Reflection.FieldInfo> object that is returned represents a field on the type that  specifies, regardless of the original source of . This practice is not recommended, because it works only if the generic type arguments of the constructed type are reference types.  \n  \n If a generic argument is a value type, the runtime type handle of the constructed type is not compatible with runtime field handles from constructions that have a reference type in the same generic parameter position, or that have a different value type in that position. In that case, the only way to use the GetFieldFromHandle overload is to ensure that  is the runtime type handle for the constructed type that  belongs to."
  example:
  - "The following example shows how to retrieve <xref:System.Reflection.FieldInfo> objects for fields on constructed generic classes. The example defines the generic type `Test<T>` (`Test(Of T)` in Visual Basic) with a single field named `TestField`, of type `T`. The example gets the <xref:System.RuntimeFieldHandle> and <xref:System.RuntimeTypeHandle> for the case where `T` is <xref:System.String>, and demonstrates the following:  \n  \n-   An exception is thrown if the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29> method overload is used. This is true even if the field is not of type `T`.  \n  \n-   A <xref:System.Reflection.FieldInfo> is retrieved successfully if the runtime type handle is from the same construction as the runtime field handle, in this case `Test<string>`.  \n  \n-   If the runtime type handle is from a compatible construction, in this case `Test<object>`, a <xref:System.Reflection.FieldInfo> for the field on the compatible construction is retrieved.  \n  \n-   If the runtime type handle is not from a compatible construction, an exception is thrown. In this case, a value type is specified for `T`.  \n  \n [!CODE [FieldInfo_GetFieldFromHandle2#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2#1)]"
  syntax:
    content: public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    parameters:
    - id: handle
      type: System.RuntimeFieldHandle
      description: A <see cref="T:System.RuntimeFieldHandle"> structure that contains the handle to the internal metadata representation of a field.
    - id: declaringType
      type: System.RuntimeTypeHandle
      description: A <see cref="T:System.RuntimeTypeHandle"> structure that contains the handle to the generic type that defines the field.
    return:
      type: System.Reflection.FieldInfo
      description: A <see cref="T:System.Reflection.FieldInfo"> object representing the field specified by , in the generic type specified by .
  overload: System.Reflection.FieldInfo.GetFieldFromHandle*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetHashCode
  id: GetHashCode
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: FieldInfo.GetHashCode()
  fullName: System.Reflection.FieldInfo.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Returns the hash code for this instance.
  remarks: To be added.
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: A 32-bit signed integer hash code.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetOptionalCustomModifiers
  id: GetOptionalCustomModifiers
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetOptionalCustomModifiers()
  nameWithType: FieldInfo.GetOptionalCustomModifiers()
  fullName: System.Reflection.FieldInfo.GetOptionalCustomModifiers()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets an array of types that identify the optional custom modifiers of the field.
  remarks: The GetOptionalCustomModifiers and <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> methods are provided for designers of managed compilers. For more information on custom modifiers, see <xref:System.Runtime.CompilerServices.IsBoxed> and related classes in the <xref:System.Runtime.CompilerServices> namespace and the metadata specification in the ECMA Partition II documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.
  syntax:
    content: public virtual Type[] GetOptionalCustomModifiers ();
    parameters: []
    return:
      type: System.Type[]
      description: An array of <see cref="T:System.Type"> objects that identify the optional custom modifiers of the current field, such as <xref:System.Runtime.CompilerServices.IsConst?displayProperty=fullName>.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetRawConstantValue
  id: GetRawConstantValue
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetRawConstantValue()
  nameWithType: FieldInfo.GetRawConstantValue()
  fullName: System.Reflection.FieldInfo.GetRawConstantValue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Returns a literal value associated with the field by a compiler.
  remarks: "This method is provided for designers of managed compilers and code analyzers.  \n  \n This method can be used in both the execution context and the reflection-only context.  \n  \n In unmanaged metadata, the Constant table is used to store constant values for fields, parameters, and properties. Constant information does not directly influence runtime behavior. Compilers inspect this information, at compile time, when importing metadata. If used, the value of a constant is embedded in the Microsoft intermediate language (MSIL) stream the compiler emits. There are no MSIL instructions that can be used to access the Constant table at run time.  \n  \n> [!NOTE]\n>  For more information on constant values and the Constant table, see the ECMA Partition II documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."
  syntax:
    content: public virtual object GetRawConstantValue ();
    parameters: []
    return:
      type: System.Object
      description: An <see cref="T:System.Object"> that contains the literal value associated with the field. If the literal value is a class type with an element value of zero, the return value is `null`.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetRequiredCustomModifiers
  id: GetRequiredCustomModifiers
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetRequiredCustomModifiers()
  nameWithType: FieldInfo.GetRequiredCustomModifiers()
  fullName: System.Reflection.FieldInfo.GetRequiredCustomModifiers()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets an array of types that identify the required custom modifiers of the property.
  remarks: The <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> and GetRequiredCustomModifiers methods are provided for designers of managed compilers. For more information on custom modifiers, see <xref:System.Runtime.CompilerServices.IsBoxed> and related classes in the <xref:System.Runtime.CompilerServices> namespace and the metadata specification in the ECMA Partition II documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.
  syntax:
    content: public virtual Type[] GetRequiredCustomModifiers ();
    parameters: []
    return:
      type: System.Type[]
      description: An array of <see cref="T:System.Type"> objects that identify the required custom modifiers of the current property, such as <xref:System.Runtime.CompilerServices.IsConst> or <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced>.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetValue(System.Object)
  id: GetValue(System.Object)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetValue(Object)
  nameWithType: FieldInfo.GetValue(Object)
  fullName: System.Reflection.FieldInfo.GetValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: When overridden in a derived class, returns the value of a field supported by a given object.
  remarks: "If the field is static,  is ignored. For non-static fields,  should be an instance of a class that inherits or declares the field. Note that the return type of `GetValue` is `Object`. For example, if the field holds a Boolean primitive value, an instance of `Object` with the appropriate Boolean value is returned. Before returning the value, `GetValue` checks to see if the user has access permission.  \n  \n> [!NOTE]\n>  Access restrictions are ignored for fully trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked through reflection whenever the code is fully trusted.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](../../add/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../add/includes/net-v35-long-md.md)] or later."
  example:
  - "The following example uses the GetValue method to retrieve the value of a static field. Note that the value of the  argument is `null`.  \n  \n [!CODE [getfldval#1](../CodeSnippet/VS_Snippets_CLR/GetFldVal#1)]  \n  \n The following example retrieves an array of <xref:System.Reflection.FieldInfo> objects that represents the fields of the `FieldsClass` type, and then calls the GetValue to display the value of each field for the `fieldsInst` object.  \n  \n [!CODE [FieldInfo_GetValue#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_GetValue#1)]"
  syntax:
    content: public abstract object GetValue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: The object whose field value will be returned.
    return:
      type: System.Object
      description: An object containing the value of the field reflected by this instance.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)
  id: GetValueDirect(System.TypedReference)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: GetValueDirect(TypedReference)
  nameWithType: FieldInfo.GetValueDirect(TypedReference)
  fullName: System.Reflection.FieldInfo.GetValueDirect(TypedReference)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Returns the value of a field supported by a given object.
  remarks: To be added.
  syntax:
    content: public virtual object GetValueDirect (TypedReference obj);
    parameters:
    - id: obj
      type: System.TypedReference
      description: A <see cref="T:System.TypedReference"> structure that encapsulates a managed pointer to a location and a runtime representation of the type that might be stored at that location.
    return:
      type: System.Object
      description: An `Object` containing a field value.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsAssembly
  id: IsAssembly
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsAssembly
  nameWithType: FieldInfo.IsAssembly
  fullName: System.Reflection.FieldInfo.IsAssembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the potential visibility of this field is described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName>; that is, the field is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.
  remarks: "The actual visibility of a field is limited by the visibility of its type. The IsAssembly property might be `true` for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.  \n  \n The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName> if the only visibility modifier is `internal` (`Friend` in Visual Basic). This property is `false` for fields that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property to identify such fields."
  example:
  - "The following code example defines fields with varying levels of visibility, and displays the values of their IsAssembly, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.  \n  \n> [!NOTE]\n>  The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  \n  \n [!CODE [Classic FieldInfo.IsAssembly Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example#1)]"
  syntax:
    content: public bool IsAssembly { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsFamily
  id: IsFamily
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsFamily
  nameWithType: FieldInfo.IsFamily
  fullName: System.Reflection.FieldInfo.IsFamily
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the visibility of this field is described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName>; that is, the field is visible only within its class and derived classes.
  remarks: The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName> if the only visibility modifier is `protected`. This property is `false` for fields that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property to identify such fields.
  example:
  - "The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, IsFamily, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.  \n  \n> [!NOTE]\n>  The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  \n  \n [!CODE [Classic FieldInfo.IsAssembly Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example#1)]"
  syntax:
    content: public bool IsFamily { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsFamilyAndAssembly
  id: IsFamilyAndAssembly
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsFamilyAndAssembly
  nameWithType: FieldInfo.IsFamilyAndAssembly
  fullName: System.Reflection.FieldInfo.IsFamilyAndAssembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the visibility of this field is described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName>; that is, the field can be accessed from derived classes, but only if they are in the same assembly.
  remarks: "If a field has <xref:System.Reflection.FieldAttributes> level visibility, it can be called from any member in a derived class that is also in the same assembly, but not from any other type.  \n  \n The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName> if the visibility modifier is `protected private` in C++. Fields with this visibility cannot be defined in Visual Basic or C#."
  example:
  - "The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and IsFamilyAndAssembly properties.  \n  \n> [!NOTE]\n>  The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  \n  \n [!CODE [Classic FieldInfo.IsAssembly Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example#1)]"
  syntax:
    content: public bool IsFamilyAndAssembly { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsFamilyOrAssembly
  id: IsFamilyOrAssembly
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsFamilyOrAssembly
  nameWithType: FieldInfo.IsFamilyOrAssembly
  fullName: System.Reflection.FieldInfo.IsFamilyOrAssembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the potential visibility of this field is described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName>; that is, the field can be accessed by derived classes wherever they are, and by classes in the same assembly.
  remarks: "If a field has <xref:System.Reflection.FieldAttributes> level visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.  \n  \n The actual visibility of a field is limited by the visibility of its type. The IsFamilyOrAssembly property might be `true` for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.  \n  \n The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes?displayProperty=fullName> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++)."
  example:
  - "The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, IsFamilyOrAssembly, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.  \n  \n> [!NOTE]\n>  The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  \n  \n [!CODE [Classic FieldInfo.IsAssembly Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example#1)]"
  syntax:
    content: public bool IsFamilyOrAssembly { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsInitOnly
  id: IsInitOnly
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsInitOnly
  nameWithType: FieldInfo.IsInitOnly
  fullName: System.Reflection.FieldInfo.IsInitOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the field can only be set in the body of the constructor.
  remarks: "If the returned value is `true`, the field can only be initialized, and is read-only thereafter.  \n  \n To get the `IsInitOnly` property, first get the class `Type`. From the `Type`, get the `FieldInfo`. From the `FieldInfo`, get the `IsInitOnly` property. To access a non-public field, combine <xref:System.Reflection.BindingFlags?displayProperty=fullName> with either or both of <xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> in the `GetField` method.  \n  \n The `IsInitOnly` property is set when the <xref:System.Reflection.FieldAttributes?displayProperty=fullName> attribute is set."
  example:
  - "In the following example, two fields are created. The second field is read-only, having no set accessor, and `IsInitOnly` is set to `true`.  \n  \n [!CODE [Classic FieldInfo.IsInitOnly Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example#1)]  \n  \n This code produces the following output:  \n  \n Reflection.FieldInfo  \n  \n Myfielda - A- modified, IsInitOnly = False  \n  \n Myfieldb - B readonly field, IsInitOnly = True"
  syntax:
    content: public bool IsInitOnly { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsLiteral
  id: IsLiteral
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsLiteral
  nameWithType: FieldInfo.IsLiteral
  fullName: System.Reflection.FieldInfo.IsLiteral
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the value is written at compile time and cannot be changed.
  remarks: The `IsLiteral` property is set when the `FieldAttributes.Literal` attribute is set. If this attribute is set, the field cannot be changed and is constant.
  syntax:
    content: public bool IsLiteral { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsNotSerialized
  id: IsNotSerialized
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsNotSerialized
  nameWithType: FieldInfo.IsNotSerialized
  fullName: System.Reflection.FieldInfo.IsNotSerialized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether this field has the `NotSerialized` attribute.
  remarks: The `IsNotSerialized` property returns `true` when the field is marked with the `FieldAttributes.NotSerialized` flag. When this flag is set on a field, it indicates that the field does not have to be serialized when the type is remoted.
  example:
  - "The following example gets the field information of the fields of MyClass, determines if the fields can be serialized, and displays the results.  \n  \n [!CODE [FieldInfo_IsNotSerialized#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_IsNotSerialized#1)]"
  syntax:
    content: public bool IsNotSerialized { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsPinvokeImpl
  id: IsPinvokeImpl
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsPinvokeImpl
  nameWithType: FieldInfo.IsPinvokeImpl
  fullName: System.Reflection.FieldInfo.IsPinvokeImpl
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the corresponding `PinvokeImpl` attribute is set in <see cref="T:System.Reflection.FieldAttributes">.
  remarks: ''
  example:
  - "The following example creates a class and displays the name, field and IsPinvokeImpl property value of the field.  \n  \n [!CODE [FieldInfo_IsPInvokeImpl#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl#1)]"
  syntax:
    content: public bool IsPinvokeImpl { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsPrivate
  id: IsPrivate
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsPrivate
  nameWithType: FieldInfo.IsPrivate
  fullName: System.Reflection.FieldInfo.IsPrivate
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the field is private.
  remarks: "Private fields are accessible only from member functions.  \n  \n The `IsPrivate` property is set when the `FieldAttributes.Private` attribute is set.  \n  \n To get the `IsPrivate` property, first get the class `Type`. From the `Type`, get the `FieldInfo`. From the `FieldInfo`, get the `IsPrivate` property. To access a non-public field, set the `BindingFlags` to `NonPublic`, and either `Static` or `Instance` in the `GetField` method."
  example:
  - "The following example returns a value indicating whether or not the field of the class is private.  \n  \n [!CODE [FieldInfo_IsPrivate#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_IsPrivate#1)]"
  syntax:
    content: public bool IsPrivate { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsPublic
  id: IsPublic
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsPublic
  nameWithType: FieldInfo.IsPublic
  fullName: System.Reflection.FieldInfo.IsPublic
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the field is public.
  remarks: "Public fields are accessible everywhere their corresponding classes are visible.  \n  \n The `IsPublic` property is set when the `FieldAttributes.Public` attribute is set.  \n  \n To get the `IsPublic` property, first get the class `Type`. From the `Type`, get the `FieldInfo`. From the `FieldInfo`, get the `IsPublic` property. If the field is other than public, it is protected and cannot be readily accessed. To access a nonpublic field, set the `BindingFlags` to `NonPublic`, specify either `BindingFlags.Instance` or `BindingFlags.Static`, and use this for the `GetField` method."
  example:
  - "The following example returns a value indicating whether or not the field of the class is public or private.  \n  \n [!CODE [Classic FieldInfo.IsPublic Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example#1)]"
  syntax:
    content: public bool IsPublic { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsSecurityCritical
  id: IsSecurityCritical
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsSecurityCritical
  nameWithType: FieldInfo.IsSecurityCritical
  fullName: System.Reflection.FieldInfo.IsSecurityCritical
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value that indicates whether the current field is security-critical or security-safe-critical at the current trust level.
  remarks: "The IsSecurityCritical, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n> [!IMPORTANT]\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \n  \n For more information about reflection and transparency, see [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md). For information about transparency, see [Security Changes](../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md)."
  syntax:
    content: public virtual bool IsSecurityCritical { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsSecuritySafeCritical
  id: IsSecuritySafeCritical
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsSecuritySafeCritical
  nameWithType: FieldInfo.IsSecuritySafeCritical
  fullName: System.Reflection.FieldInfo.IsSecuritySafeCritical
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value that indicates whether the current field is security-safe-critical at the current trust level.
  remarks: "The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, IsSecuritySafeCritical, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n> [!IMPORTANT]\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \n  \n For more information about reflection and transparency, see [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md). For information about transparency, see [Security Changes](../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md)."
  syntax:
    content: public virtual bool IsSecuritySafeCritical { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsSecurityTransparent
  id: IsSecurityTransparent
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsSecurityTransparent
  nameWithType: FieldInfo.IsSecurityTransparent
  fullName: System.Reflection.FieldInfo.IsSecurityTransparent
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value that indicates whether the current field is transparent at the current trust level.
  remarks: "The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and IsSecurityTransparent properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n> [!IMPORTANT]\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \n  \n For more information about reflection and transparency, see [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md). For information about transparency, see [Security Changes](../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md)."
  syntax:
    content: public virtual bool IsSecurityTransparent { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsSpecialName
  id: IsSpecialName
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsSpecialName
  nameWithType: FieldInfo.IsSpecialName
  fullName: System.Reflection.FieldInfo.IsSpecialName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the corresponding `SpecialName` attribute is set in the <see cref="T:System.Reflection.FieldAttributes"> enumerator.
  remarks: Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of names that might require special treatment by some compilers.
  example:
  - "The following example returns a value indicating whether or not the fields in the class contain a SpecialName attribute.  \n  \n [!CODE [FieldInfo_IsSpecialName#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_IsSpecialName#1)]"
  syntax:
    content: public bool IsSpecialName { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.IsStatic
  id: IsStatic
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: IsStatic
  nameWithType: FieldInfo.IsStatic
  fullName: System.Reflection.FieldInfo.IsStatic
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a value indicating whether the field is static.
  remarks: "When a field is static, one copy of the field is shared by all instances of the type.  \n  \n The `IsStatic` property is set when the `FieldAttributes.Static` attribute is set.  \n  \n To get the `IsStatic` property, first get the class `Type`. From the `Type`, get the `FieldInfo`. From the `FieldInfo`, get the `IsStatic` property. To access a non-public field, set the `BindingFlags` to `NonPublic` in the `GetField` method and set the accessibility to `Instance` or `Static`."
  example:
  - "The following example determines whether the specified field is static and displays the result.  \n  \n [!CODE [Classic FieldInfo.IsStatic Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example#1)]  \n  \n This code produces the following output:  \n  \n Reflection.FieldInfo  \n  \n Myfielda - A private field; IsStatic - False  \n  \n Myfieldb - B static field; IsStatic - True"
  syntax:
    content: public bool IsStatic { get; }
    return:
      type: System.Boolean
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.MemberType
  id: MemberType
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: MemberType
  nameWithType: FieldInfo.MemberType
  fullName: System.Reflection.FieldInfo.MemberType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a <see cref="T:System.Reflection.MemberTypes"> value indicating that this member is a field.
  remarks: This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A>. Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects — for example, the array returned by <xref:System.Type.GetMembers%2A> — the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes?displayProperty=fullName> only when a given member is a field.
  example:
  - "The following example determines whether the specified member is a field and displays the result.  \n  \n [!CODE [Classic FieldInfo.MemberType Example#1](../CodeSnippet/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example#1)]  \n  \n This code produces the following output:  \n  \n Reflection.FieldInfo  \n  \n Myfield.field - a private field; MemberType is a Field"
  syntax:
    content: public override System.Reflection.MemberTypes MemberType { get; }
    return:
      type: System.Reflection.MemberTypes
      description: To be added.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  id: op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: op_Equality(FieldInfo,FieldInfo)
  nameWithType: FieldInfo.op_Equality(FieldInfo,FieldInfo)
  fullName: System.Reflection.FieldInfo.op_Equality(FieldInfo,FieldInfo)
  type: Operator
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Indicates whether two <see cref="T:System.Reflection.FieldInfo"> objects are equal.
  remarks: To be added.
  syntax:
    content: public static bool op_Equality (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);
    parameters:
    - id: left
      type: System.Reflection.FieldInfo
      description: The first object to compare.
    - id: right
      type: System.Reflection.FieldInfo
      description: The second object to compare.
    return:
      type: System.Boolean
      description: '`true` if  is equal to ; otherwise, `false`.'
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  id: op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: op_Inequality(FieldInfo,FieldInfo)
  nameWithType: FieldInfo.op_Inequality(FieldInfo,FieldInfo)
  fullName: System.Reflection.FieldInfo.op_Inequality(FieldInfo,FieldInfo)
  type: Operator
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Indicates whether two <see cref="T:System.Reflection.FieldInfo"> objects are not equal.
  remarks: To be added.
  syntax:
    content: public static bool op_Inequality (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);
    parameters:
    - id: left
      type: System.Reflection.FieldInfo
      description: The first object to compare.
    - id: right
      type: System.Reflection.FieldInfo
      description: The second object to compare.
    return:
      type: System.Boolean
      description: '`true` if  is not equal to ; otherwise, `false`.'
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.SetValue(System.Object,System.Object)
  id: SetValue(System.Object,System.Object)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: SetValue(Object,Object)
  nameWithType: FieldInfo.SetValue(Object,Object)
  fullName: System.Reflection.FieldInfo.SetValue(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Sets the value of the field supported by the given object.
  remarks: "This method will assign  to the field reflected by this instance on object . If the field is static,  will be ignored. For non-static fields,  should be an instance of a class that inherits or declares the field. The new value is passed as an `Object`. For example, if the field's type is Boolean, an instance of `Object` with the appropriate Boolean value is passed. Before setting the value, `SetValue` checks to see if the user has access permission. This final method is a convenience method for calling the following `SetValue` method.  \n  \n> [!NOTE]\n>  Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](../../add/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../add/includes/net-v35-long-md.md)] or later."
  example:
  - "The following example sets the value of a field, gets and displays the value, modifies the field, and displays the result.  \n  \n [!CODE [FieldInfo_SetValue#1](../CodeSnippet/VS_Snippets_CLR/FieldInfo_SetValue#1)]"
  syntax:
    content: public void SetValue (object obj, object value);
    parameters:
    - id: obj
      type: System.Object
      description: The object whose field value will be set.
    - id: value
      type: System.Object
      description: The value to assign to the field.
  overload: System.Reflection.FieldInfo.SetValue*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)
  id: SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: SetValue(Object,Object,BindingFlags,Binder,CultureInfo)
  nameWithType: FieldInfo.SetValue(Object,Object,BindingFlags,Binder,CultureInfo)
  fullName: System.Reflection.FieldInfo.SetValue(Object,Object,BindingFlags,Binder,CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: When overridden in a derived class, sets the value of the field supported by the given object.
  remarks: "This method will assign  to the field reflected by this instance on . If the field is static,  will be ignored. For non-static fields,  should be an instance of a class that inherits or declares the field. The new value is passed as an `Object`. For example, if the field's type is `Boolean`, an instance of `Object` with the appropriate Boolean value is passed. Before setting the value, `SetValue` checks to see if the user has access permission.  \n  \n> [!NOTE]\n>  Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](../../add/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../add/includes/net-v35-long-md.md)] or later."
  syntax:
    content: public abstract void SetValue (object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
    parameters:
    - id: obj
      type: System.Object
      description: The object whose field value will be set.
    - id: value
      type: System.Object
      description: The value to assign to the field.
    - id: invokeAttr
      type: System.Reflection.BindingFlags
      description: A field of `Binder` that specifies the type of binding that is desired (for example, `Binder.CreateInstance` or `Binder.ExactBinding`).
    - id: binder
      type: System.Reflection.Binder
      description: A set of properties that enables the binding, coercion of argument types, and invocation of members through reflection. If  is `null`, then `Binder.DefaultBinding` is used.
    - id: culture
      type: System.Globalization.CultureInfo
      description: The software preferences of a particular culture.
  overload: System.Reflection.FieldInfo.SetValue*
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)
  id: SetValueDirect(System.TypedReference,System.Object)
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: SetValueDirect(TypedReference,Object)
  nameWithType: FieldInfo.SetValueDirect(TypedReference,Object)
  fullName: System.Reflection.FieldInfo.SetValueDirect(TypedReference,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Sets the value of the field supported by the given object.
  remarks: "> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](../../add/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../add/includes/net-v35-long-md.md)] or later."
  syntax:
    content: public virtual void SetValueDirect (TypedReference obj, object value);
    parameters:
    - id: obj
      type: System.TypedReference
      description: A <see cref="T:System.TypedReference"> structure that encapsulates a managed pointer to a location and a runtime representation of the type that can be stored at that location.
    - id: value
      type: System.Object
      description: The value to assign to the field.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Maps a set of names to a corresponding set of dispatch identifiers.
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.
  syntax:
    content: void _FieldInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: Reserved for future use. Must be IID_NULL.
    - id: rgszNames
      type: System.IntPtr
      description: Passed-in array of names to be mapped.
    - id: cNames
      type: System.UInt32
      description: Count of the names to be mapped.
    - id: lcid
      type: System.UInt32
      description: The locale context in which to interpret the names.
    - id: rgDispId
      type: System.IntPtr
      description: Caller-allocated array which receives the IDs corresponding to the names.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType
  id: System#Runtime#InteropServices#_FieldInfo#GetType
  isEii: true
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: System.Runtime.InteropServices._FieldInfo.GetType()
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetType()
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Gets a <see cref="T:System.Type"> object representing the <xref:System.Reflection.FieldInfo> type.
  remarks: To be added.
  syntax:
    content: Type _FieldInfo.GetType ();
    parameters: []
    return:
      type: System.Type
      description: A <see cref="T:System.Type"> object representing the <xref:System.Reflection.FieldInfo> type.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Retrieves the type information for an object, which can then be used to get the type information for an interface.
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.
  syntax:
    content: void _FieldInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: The type information to return.
    - id: lcid
      type: System.UInt32
      description: The locale identifier for the type information.
    - id: ppTInfo
      type: System.IntPtr
      description: Receives a pointer to the requested type information object.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Retrieves the number of type information interfaces that an object provides (either 0 or 1).
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.
  syntax:
    content: void _FieldInfo.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: Points to a location that receives the number of type information interfaces provided by the object.
  platform:
  - net-11
  - net-20
  - netcore-10
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Reflection.FieldInfo
  langs:
  - csharp
  name: System.Runtime.InteropServices._FieldInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: Provides access to properties and methods exposed by an object.
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.
  syntax:
    content: void _FieldInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: Identifies the member.
    - id: riid
      type: System.Guid
      description: Reserved for future use. Must be IID_NULL.
    - id: lcid
      type: System.UInt32
      description: The locale context in which to interpret arguments.
    - id: wFlags
      type: System.Int16
      description: Flags describing the context of the call.
    - id: pDispParams
      type: System.IntPtr
      description: Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.
    - id: pVarResult
      type: System.IntPtr
      description: Pointer to the location where the result is to be stored.
    - id: pExcepInfo
      type: System.IntPtr
      description: Pointer to a structure that contains exception information.
    - id: puArgErr
      type: System.IntPtr
      description: The index of the first argument that has an error.
  platform:
  - net-11
  - net-20
  - netcore-10
references:
- uid: System.Reflection.MemberInfo
  isExternal: false
  name: System.Reflection.MemberInfo
- uid: System.Reflection.FieldInfo.#ctor
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: FieldInfo()
  nameWithType: FieldInfo.FieldInfo()
  fullName: System.Reflection.FieldInfo.FieldInfo()
- uid: System.Reflection.FieldInfo.Attributes
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: Attributes
  nameWithType: FieldInfo.Attributes
  fullName: System.Reflection.FieldInfo.Attributes
- uid: System.Reflection.FieldAttributes
  parent: System.Reflection
  isExternal: false
  name: FieldAttributes
  nameWithType: FieldAttributes
  fullName: System.Reflection.FieldAttributes
- uid: System.Reflection.FieldInfo.Equals(System.Object)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: Equals(Object)
  nameWithType: FieldInfo.Equals(Object)
  fullName: System.Reflection.FieldInfo.Equals(Object)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Reflection.FieldInfo.FieldHandle
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: FieldHandle
  nameWithType: FieldInfo.FieldHandle
  fullName: System.Reflection.FieldInfo.FieldHandle
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: false
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.Reflection.FieldInfo.FieldType
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: FieldType
  nameWithType: FieldInfo.FieldType
  fullName: System.Reflection.FieldInfo.FieldType
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetFieldFromHandle(RuntimeFieldHandle)
  nameWithType: FieldInfo.GetFieldFromHandle(RuntimeFieldHandle)
  fullName: System.Reflection.FieldInfo.GetFieldFromHandle(RuntimeFieldHandle)
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: false
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetFieldFromHandle(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: FieldInfo.GetFieldFromHandle(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.FieldInfo.GetFieldFromHandle(RuntimeFieldHandle,RuntimeTypeHandle)
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: false
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: false
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.FieldInfo.GetHashCode
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetHashCode()
  nameWithType: FieldInfo.GetHashCode()
  fullName: System.Reflection.FieldInfo.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Reflection.FieldInfo.GetOptionalCustomModifiers
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetOptionalCustomModifiers()
  nameWithType: FieldInfo.GetOptionalCustomModifiers()
  fullName: System.Reflection.FieldInfo.GetOptionalCustomModifiers()
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type[]
- uid: System.Reflection.FieldInfo.GetRawConstantValue
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetRawConstantValue()
  nameWithType: FieldInfo.GetRawConstantValue()
  fullName: System.Reflection.FieldInfo.GetRawConstantValue()
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Reflection.FieldInfo.GetRequiredCustomModifiers
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetRequiredCustomModifiers()
  nameWithType: FieldInfo.GetRequiredCustomModifiers()
  fullName: System.Reflection.FieldInfo.GetRequiredCustomModifiers()
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type[]
- uid: System.Reflection.FieldInfo.GetValue(System.Object)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetValue(Object)
  nameWithType: FieldInfo.GetValue(Object)
  fullName: System.Reflection.FieldInfo.GetValue(Object)
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: GetValueDirect(TypedReference)
  nameWithType: FieldInfo.GetValueDirect(TypedReference)
  fullName: System.Reflection.FieldInfo.GetValueDirect(TypedReference)
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.TypedReference
  parent: System
  isExternal: false
  name: TypedReference
  nameWithType: TypedReference
  fullName: System.TypedReference
- uid: System.Reflection.FieldInfo.IsAssembly
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsAssembly
  nameWithType: FieldInfo.IsAssembly
  fullName: System.Reflection.FieldInfo.IsAssembly
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsFamily
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsFamily
  nameWithType: FieldInfo.IsFamily
  fullName: System.Reflection.FieldInfo.IsFamily
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsFamilyAndAssembly
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsFamilyAndAssembly
  nameWithType: FieldInfo.IsFamilyAndAssembly
  fullName: System.Reflection.FieldInfo.IsFamilyAndAssembly
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsFamilyOrAssembly
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsFamilyOrAssembly
  nameWithType: FieldInfo.IsFamilyOrAssembly
  fullName: System.Reflection.FieldInfo.IsFamilyOrAssembly
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsInitOnly
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsInitOnly
  nameWithType: FieldInfo.IsInitOnly
  fullName: System.Reflection.FieldInfo.IsInitOnly
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsLiteral
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsLiteral
  nameWithType: FieldInfo.IsLiteral
  fullName: System.Reflection.FieldInfo.IsLiteral
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsNotSerialized
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsNotSerialized
  nameWithType: FieldInfo.IsNotSerialized
  fullName: System.Reflection.FieldInfo.IsNotSerialized
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsPinvokeImpl
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsPinvokeImpl
  nameWithType: FieldInfo.IsPinvokeImpl
  fullName: System.Reflection.FieldInfo.IsPinvokeImpl
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsPrivate
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsPrivate
  nameWithType: FieldInfo.IsPrivate
  fullName: System.Reflection.FieldInfo.IsPrivate
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsPublic
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsPublic
  nameWithType: FieldInfo.IsPublic
  fullName: System.Reflection.FieldInfo.IsPublic
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsSecurityCritical
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsSecurityCritical
  nameWithType: FieldInfo.IsSecurityCritical
  fullName: System.Reflection.FieldInfo.IsSecurityCritical
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsSecuritySafeCritical
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsSecuritySafeCritical
  nameWithType: FieldInfo.IsSecuritySafeCritical
  fullName: System.Reflection.FieldInfo.IsSecuritySafeCritical
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsSecurityTransparent
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsSecurityTransparent
  nameWithType: FieldInfo.IsSecurityTransparent
  fullName: System.Reflection.FieldInfo.IsSecurityTransparent
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsSpecialName
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsSpecialName
  nameWithType: FieldInfo.IsSpecialName
  fullName: System.Reflection.FieldInfo.IsSpecialName
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.IsStatic
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: IsStatic
  nameWithType: FieldInfo.IsStatic
  fullName: System.Reflection.FieldInfo.IsStatic
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo.MemberType
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: MemberType
  nameWithType: FieldInfo.MemberType
  fullName: System.Reflection.FieldInfo.MemberType
- uid: System.Reflection.MemberTypes
  parent: System.Reflection
  isExternal: false
  name: MemberTypes
  nameWithType: MemberTypes
  fullName: System.Reflection.MemberTypes
- uid: System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: op_Equality(FieldInfo,FieldInfo)
  nameWithType: FieldInfo.op_Equality(FieldInfo,FieldInfo)
  fullName: System.Reflection.FieldInfo.op_Equality(FieldInfo,FieldInfo)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: op_Inequality(FieldInfo,FieldInfo)
  nameWithType: FieldInfo.op_Inequality(FieldInfo,FieldInfo)
  fullName: System.Reflection.FieldInfo.op_Inequality(FieldInfo,FieldInfo)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.FieldInfo.SetValue(System.Object,System.Object)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: SetValue(Object,Object)
  nameWithType: FieldInfo.SetValue(Object,Object)
  fullName: System.Reflection.FieldInfo.SetValue(Object,Object)
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: SetValue(Object,Object,BindingFlags,Binder,CultureInfo)
  nameWithType: FieldInfo.SetValue(Object,Object,BindingFlags,Binder,CultureInfo)
  fullName: System.Reflection.FieldInfo.SetValue(Object,Object,BindingFlags,Binder,CultureInfo)
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: false
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: SetValueDirect(TypedReference,Object)
  nameWithType: FieldInfo.SetValueDirect(TypedReference,Object)
  fullName: System.Reflection.FieldInfo.SetValueDirect(TypedReference,Object)
- uid: System.TypedReference
  parent: System
  isExternal: false
  name: TypedReference
  nameWithType: TypedReference
  fullName: System.TypedReference
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: false
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: System.Runtime.InteropServices._FieldInfo.GetType()
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetType()
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetType()
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32)
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Reflection.FieldInfo
  isExternal: false
  name: System.Runtime.InteropServices._FieldInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: FieldInfo.System.Runtime.InteropServices._FieldInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Reflection.FieldInfo.System.Runtime.InteropServices._FieldInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Guid
  parent: System
  isExternal: false
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Int16
  parent: System
  isExternal: false
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Reflection.FieldInfo.GetFieldFromHandle*
  parent: System.Reflection.FieldInfo
  isExternal: false
  nameWithType: FieldInfo.
- uid: System.Reflection.FieldInfo.SetValue*
  parent: System.Reflection.FieldInfo
  isExternal: false
  nameWithType: FieldInfo.
